(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["pdfviewerbase"],{

/***/ "./bundles/pdfviewerbase.js":
/*!**********************************!*\
  !*** ./bundles/pdfviewerbase.js ***!
  \**********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_pdfviewerbase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/pdfviewerbase.js */ "./modules/pdfviewerbase.js");


/***/ }),

/***/ "./modules/pdfviewerbase.js":
/*!**********************************!*\
  !*** ./modules/pdfviewerbase.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);

window.sf = window.sf || {};

var pdfviewerbase = function pdfviewerbase(exports) {
  'use strict';

  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * The `PdfBounds` is base for annotation bounds.
   * @hidden
   */


  var PdfBounds =
  /** @class */
  function (_super) {
    __extends(PdfBounds, _super);

    function PdfBounds() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "x", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "y", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "width", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "height", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "left", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "top", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "right", void 0);

    __decorate([sf.base.Property(0)], PdfBounds.prototype, "bottom", void 0);

    __decorate([sf.base.Complex({
      x: 0,
      y: 0
    }, sf.drawings.Point)], PdfBounds.prototype, "location", void 0);

    __decorate([sf.base.Complex(new sf.drawings.Size(0, 0), sf.drawings.Size)], PdfBounds.prototype, "size", void 0);

    return PdfBounds;
  }(sf.base.ChildProperty);
  /**
   * The `PdfFont` is base for annotation Text styles.
   * @hidden
   */


  var PdfFont =
  /** @class */
  function (_super) {
    __extends(PdfFont, _super);

    function PdfFont() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    __decorate([sf.base.Property(false)], PdfFont.prototype, "isBold", void 0);

    __decorate([sf.base.Property(false)], PdfFont.prototype, "isItalic", void 0);

    __decorate([sf.base.Property(false)], PdfFont.prototype, "isUnderline", void 0);

    __decorate([sf.base.Property(false)], PdfFont.prototype, "isStrikeout", void 0);

    return PdfFont;
  }(sf.base.ChildProperty);
  /**
   * Defines the common behavior of PdfAnnotationBase
   * @hidden
   */


  var PdfAnnotationBase =
  /** @class */
  function (_super) {
    __extends(PdfAnnotationBase, _super); // tslint:disable-next-line:no-any


    function PdfAnnotationBase(parent, propName, defaultValue, isArray) {
      return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "id", void 0);

    __decorate([sf.base.Property('Rectangle')], PdfAnnotationBase.prototype, "shapeAnnotationType", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "measureType", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "author", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "modifiedDate", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "subject", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "notes", void 0);

    __decorate([sf.base.Property('black')], PdfAnnotationBase.prototype, "strokeColor", void 0);

    __decorate([sf.base.Property('#ffffff00')], PdfAnnotationBase.prototype, "fillColor", void 0);

    __decorate([sf.base.Property('#ffffff00')], PdfAnnotationBase.prototype, "stampFillColor", void 0);

    __decorate([sf.base.Property('black')], PdfAnnotationBase.prototype, "stampStrokeColor", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "data", void 0);

    __decorate([sf.base.Property(1)], PdfAnnotationBase.prototype, "opacity", void 0);

    __decorate([sf.base.Property(1)], PdfAnnotationBase.prototype, "thickness", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "borderStyle", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "borderDashArray", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "rotateAngle", void 0);

    __decorate([sf.base.Property(false)], PdfAnnotationBase.prototype, "isCloudShape", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "cloudIntensity", void 0);

    __decorate([sf.base.Property(40)], PdfAnnotationBase.prototype, "leaderHeight", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "lineHeadStart", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "lineHeadEnd", void 0);

    __decorate([sf.base.Property([])], PdfAnnotationBase.prototype, "vertexPoints", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "sourcePoint", void 0);

    __decorate([sf.base.Property('None')], PdfAnnotationBase.prototype, "sourceDecoraterShapes", void 0);

    __decorate([sf.base.Property('None')], PdfAnnotationBase.prototype, "taregetDecoraterShapes", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "targetPoint", void 0);

    __decorate([sf.base.Property([])], PdfAnnotationBase.prototype, "segments", void 0);

    __decorate([sf.base.Complex({
      x: 0,
      y: 0
    }, PdfBounds)], PdfAnnotationBase.prototype, "bounds", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "pageIndex", void 0);

    __decorate([sf.base.Property(-1)], PdfAnnotationBase.prototype, "zIndex", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "wrapper", void 0);

    __decorate([sf.base.Property(false)], PdfAnnotationBase.prototype, "isDynamicStamp", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "dynamicText", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "annotName", void 0);

    __decorate([sf.base.Property({})], PdfAnnotationBase.prototype, "review", void 0);

    __decorate([sf.base.Property([])], PdfAnnotationBase.prototype, "comments", void 0);

    __decorate([sf.base.Property('#000')], PdfAnnotationBase.prototype, "fontColor", void 0);

    __decorate([sf.base.Property(16)], PdfAnnotationBase.prototype, "fontSize", void 0);

    __decorate([sf.base.Property('Helvetica')], PdfAnnotationBase.prototype, "fontFamily", void 0);

    __decorate([sf.base.Property(false)], PdfAnnotationBase.prototype, "enableShapeLabel", void 0);

    __decorate([sf.base.Property('label')], PdfAnnotationBase.prototype, "labelContent", void 0);

    __decorate([sf.base.Property('#ffffff00')], PdfAnnotationBase.prototype, "labelFillColor", void 0);

    __decorate([sf.base.Property(15)], PdfAnnotationBase.prototype, "labelMaxLength", void 0);

    __decorate([sf.base.Property(1)], PdfAnnotationBase.prototype, "labelOpacity", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "annotationSelectorSettings", void 0);

    __decorate([sf.base.Property('#ffffff00')], PdfAnnotationBase.prototype, "labelBorderColor", void 0);

    __decorate([sf.base.Property('left')], PdfAnnotationBase.prototype, "textAlign", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "signatureName", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "minHeight", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "minWidth", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "maxHeight", void 0);

    __decorate([sf.base.Property(0)], PdfAnnotationBase.prototype, "maxWidth", void 0);

    __decorate([sf.base.Property(false)], PdfAnnotationBase.prototype, "isLock", void 0);

    __decorate([sf.base.Property('UI Drawn Annotation')], PdfAnnotationBase.prototype, "annotationAddMode", void 0);

    __decorate([sf.base.Property('')], PdfAnnotationBase.prototype, "annotationSettings", void 0);

    __decorate([sf.base.Property(16)], PdfAnnotationBase.prototype, "previousFontSize", void 0);

    __decorate([sf.base.Complex({
      isBold: false,
      isItalic: false,
      isStrikeout: false,
      isUnderline: false
    }, PdfFont)], PdfAnnotationBase.prototype, "font", void 0);

    __decorate([sf.base.Complex({
      x: 0,
      y: 0
    }, PdfBounds)], PdfAnnotationBase.prototype, "labelBounds", void 0);

    __decorate([sf.base.Property(null)], PdfAnnotationBase.prototype, "customData", void 0);

    return PdfAnnotationBase;
  }(sf.base.ChildProperty);
  /**
   * @hidden
   */


  var ZOrderPageTable =
  /** @class */
  function () {
    function ZOrderPageTable() {
      this.pageIdTemp = 0;
      this.zIndexTemp = -1;
      this.childNodesTemp = [];
      this.objects = [];
      this.zIndexTemp = -1;
      this.pageIdTemp = 0;
    }

    Object.defineProperty(ZOrderPageTable.prototype, "pageId", {
      /** @private */
      get: function get() {
        return this.pageIdTemp;
      },

      /** @private */
      set: function set(offset) {
        this.pageIdTemp = offset;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZOrderPageTable.prototype, "zIndex", {
      /** @private */
      get: function get() {
        return this.zIndexTemp;
      },

      /** @private */
      set: function set(offset) {
        this.zIndexTemp = offset;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZOrderPageTable.prototype, "objects", {
      /** @private */
      get: function get() {
        return this.childNodesTemp;
      },

      /** @private */
      set: function set(childNodes) {
        this.childNodesTemp = childNodes;
      },
      enumerable: true,
      configurable: true
    });
    return ZOrderPageTable;
  }();

  var __extends$1 = undefined && undefined.__extends || function () {
    var _extendStatics2 = function extendStatics(d, b) {
      _extendStatics2 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics2(d, b);
    };

    return function (d, b) {
      _extendStatics2(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the size and position of selected items and defines the appearance of selector
   * @hidden
   */


  var Selector =
  /** @class */
  function (_super) {
    __extends$1(Selector, _super);

    function Selector() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initializes the UI of the container
     */
    // tslint:disable-next-line


    Selector.prototype.init = function (diagram) {
      var container = new sf.drawings.Container();
      container.measureChildren = false;
      var consize = new sf.drawings.Size();
      container.children = [];

      if (this.annotations) {
        for (var i = 0; i < this.annotations.length; i++) {
          var node = diagram.pdfViewer.nameTable[this.annotations[i].id];
          var wrapper = node.wrapper;
          container.children.push(wrapper);
        }
      }

      this.wrapper = container;
      return container;
    };

    __decorate$1([sf.base.Property(null)], Selector.prototype, "wrapper", void 0);

    __decorate$1([sf.base.Collection([], PdfAnnotationBase)], Selector.prototype, "annotations", void 0);

    __decorate$1([sf.base.Property()], Selector.prototype, "width", void 0);

    __decorate$1([sf.base.Property()], Selector.prototype, "height", void 0);

    __decorate$1([sf.base.Property(0)], Selector.prototype, "rotateAngle", void 0);

    __decorate$1([sf.base.Property(0)], Selector.prototype, "offsetX", void 0);

    __decorate$1([sf.base.Property(0)], Selector.prototype, "offsetY", void 0);

    __decorate$1([sf.base.Complex({
      x: 0.5,
      y: 0.5
    }, sf.drawings.Point)], Selector.prototype, "pivot", void 0);

    return Selector;
  }(sf.base.ChildProperty); // tslint:disable-next-line:max-line-length

  /**
   * @hidden
   */


  function isLineShapes(obj) {
    if (obj.shapeAnnotationType === 'Line' || obj.shapeAnnotationType === 'LineWidthArrowHead' || obj.shapeAnnotationType === 'Distance' || obj.shapeAnnotationType === 'Polygon') {
      return true;
    }

    return false;
  }
  /**
   * @hidden
   */


  function setElementStype(obj, element) {
    if (obj && element) {
      var fillColor = obj.fillColor === '#ffffff00' ? 'transparent' : obj.fillColor;
      element.style.fill = fillColor;
      element.style.strokeColor = obj.strokeColor;
      element.style.color = obj.strokeColor;
      element.style.strokeWidth = obj.thickness;
      element.style.strokeDashArray = obj.borderDashArray;
      element.style.opacity = obj.opacity;
    }
  }
  /**
   * @hidden
   */


  function findPointsLength(points) {
    var length = 0;

    for (var i = 0; i < points.length - 1; i++) {
      length += sf.drawings.Point.findLength(points[i], points[i + 1]);
    }

    return length;
  }
  /**
   * @hidden
   */


  function findPerimeterLength(points) {
    var length = sf.drawings.Point.getLengthFromListOfPoints(points);
    return length;
  }
  /**   @private  */


  function getBaseShapeAttributes(element, transform) {
    var baseShapeAttributes = {
      width: element.actualSize.width,
      height: element.actualSize.height,
      x: element.offsetX - element.actualSize.width * element.pivot.x + 0.5,
      y: element.offsetY - element.actualSize.height * element.pivot.y + 0.5,
      angle: element.rotateAngle + element.parentTransform,
      fill: element.style.fill,
      stroke: element.style.strokeColor,
      pivotX: element.pivot.x,
      pivotY: element.pivot.y,
      strokeWidth: 1,
      opacity: element.style.opacity,
      dashArray: element.style.strokeDashArray || '',
      visible: element.visible,
      id: element.id
    };

    if (transform) {
      baseShapeAttributes.x += transform.tx;
      baseShapeAttributes.y += transform.ty;
    }

    return baseShapeAttributes;
  }
  /**
   * Get function
   * @private
   */


  function getFunction(value) {
    if (value !== undefined) {
      if (typeof value === 'string') {
        value = sf.base.getValue(value, window);
      }
    }

    return value;
  }
  /** @private */
  // tslint:disable-next-line


  function cloneObject(obj, additionalProp, key) {
    // tslint:disable-next-line
    var newObject = {};
    var keys = 'properties';
    var prop = 'propName';

    if (obj) {
      key = obj[prop];
      var sourceObject = obj[keys] || obj;
      var properties = [];
      properties = properties.concat(Object.keys(sourceObject));
      var customProperties = [];
      properties.push('version');

      if (key) {
        var propAdditional = getFunction(additionalProp);

        if (propAdditional) {
          customProperties = propAdditional(key);
        } else {
          customProperties = [];
        }

        properties = properties.concat(customProperties);
      }

      var internalProp = getInternalProperties(key);
      properties = properties.concat(internalProp);

      for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
        var property = properties_1[_i];

        if (property !== 'historyManager') {
          if (property !== 'wrapper') {
            var isEventEmmitter = obj[property] && obj.hasOwnProperty('observers') ? true : false;

            if (!isEventEmmitter) {
              if (obj[property] instanceof Array) {
                newObject[property] = cloneArray(internalProp.indexOf(property) === -1 && obj[keys] ? obj[keys][property] : obj[property], additionalProp, property);
              } else if (obj[property] instanceof Array === false && obj[property] instanceof HTMLElement) {
                newObject[property] = obj[property].cloneNode(true).innerHtml;
              } else if (obj[property] instanceof Array === false && obj[property] instanceof Object) {
                newObject[property] = cloneObject(internalProp.indexOf(property) === -1 && obj[keys] ? obj[keys][property] : obj[property]);
              } else {
                newObject[property] = obj[property];
              }
            }
          } else {
            if (obj[property]) {
              newObject[property] = {
                actualSize: {
                  width: obj[property].actualSize.width,
                  height: obj[property].actualSize.height
                },
                offsetX: obj[property].offsetX,
                offsetY: obj[property].offsetY
              };
            }
          }
        }
      }
    }

    return newObject;
  }
  /** @private */


  function cloneArray(sourceArray, additionalProp, key) {
    var clonedArray;

    if (sourceArray) {
      clonedArray = [];

      for (var i = 0; i < sourceArray.length; i++) {
        if (sourceArray[i] instanceof Array) {
          clonedArray.push(sourceArray[i]);
        } else if (sourceArray[i] instanceof Object) {
          clonedArray.push(cloneObject(sourceArray[i], additionalProp, key));
        } else {
          clonedArray.push(sourceArray[i]);
        }
      }
    }

    return clonedArray;
  }
  /** @private */


  function getInternalProperties(propName) {
    switch (propName) {
      case 'nodes':
      case 'children':
        return ['inEdges', 'outEdges', 'parentId', 'processId', 'nodeId', 'umlIndex', 'isPhase', 'isLane'];

      case 'connectors':
        return ['parentId'];

      case 'annotation':
        return ['nodeId'];

      case 'annotations':
        return ['nodeId'];

      case 'shape':
        return ['hasHeader'];
    }

    return [];
  }
  /**
   * @hidden
   */


  function isLeader(obj, position) {
    var rotatedPoint;

    if (obj.shapeAnnotationType === 'Distance') {
      var leaderCount = 0;
      var newPoint1 = void 0;

      for (var i = 0; i < obj.wrapper.children.length; i++) {
        var angle = sf.drawings.Point.findAngle(obj.sourcePoint, obj.targetPoint); // tslint:disable-next-line

        var segment = obj.wrapper.children[i];

        if (segment.id.indexOf('leader') > -1) {
          var center = obj.wrapper.children[0].bounds.center;

          if (leaderCount === 0) {
            newPoint1 = {
              x: obj.sourcePoint.x,
              y: obj.sourcePoint.y - obj.leaderHeight
            };
            var center_1 = obj.sourcePoint;
          } else {
            newPoint1 = {
              x: obj.targetPoint.x,
              y: obj.targetPoint.y - obj.leaderHeight
            };
            center = obj.targetPoint;
          }

          var matrix = sf.drawings.identityMatrix();
          sf.drawings.rotateMatrix(matrix, angle, center.x, center.y);
          rotatedPoint = sf.drawings.transformPointByMatrix(matrix, {
            x: newPoint1.x,
            y: newPoint1.y
          });

          if (position === 'Leader' + leaderCount) {
            return {
              leader: 'leader' + leaderCount,
              point: rotatedPoint
            };
          }

          leaderCount++;
        }
      }
    }

    return {
      leader: '',
      point: rotatedPoint
    };
  } // tslint:disable-next-line:max-line-length

  /** @private */


  function getConnectorPoints(obj, points) {
    var width = Math.abs(obj.sourcePoint.x - obj.targetPoint.x);
    var height = Math.abs(obj.sourcePoint.y - obj.targetPoint.y);
    points = obj.vertexPoints;
    var newPoints = points.slice(0);

    if (newPoints && newPoints.length > 0) {
      obj.sourcePoint = newPoints[0];
      obj.targetPoint = newPoints[newPoints.length - 1];
    }

    return newPoints;
  }
  /** @private */


  function getSegmentPath(connector, points) {
    var path = '';
    var getPt;
    var pts = [];
    var j = 0;

    while (j < points.length) {
      pts.push({
        x: points[j].x,
        y: points[j].y
      });
      j++;
    }

    pts = clipDecorators(connector, pts);

    for (var k = 0; k < pts.length; k++) {
      getPt = pts[k];

      if (k === 0) {
        path = 'M' + getPt.x + ' ' + getPt.y;
      }

      if (k > 0) {
        path += ' ' + 'L' + getPt.x + ' ' + getPt.y;
      }
    }

    return path;
  }
  /** @private */


  function updateSegmentElement(connector, points, element) {
    var segmentPath;
    var bounds = new sf.drawings.Rect();
    segmentPath = getSegmentPath(connector, points);
    bounds = sf.drawings.Rect.toBounds(points);
    element.width = bounds.width;
    element.height = bounds.height;
    element.offsetX = bounds.x + element.width / 2;
    element.offsetY = bounds.y + element.height / 2;
    element.data = segmentPath;

    if (connector.wrapper) {
      connector.wrapper.offsetX = element.offsetX;
      connector.wrapper.offsetY = element.offsetY;
      connector.wrapper.width = bounds.width;
      connector.wrapper.height = bounds.height;
    }

    return element;
  }
  /** @private */


  function getSegmentElement(connector, segmentElement) {
    var points = [];
    points = getConnectorPoints(connector);
    segmentElement.staticSize = true;
    segmentElement = updateSegmentElement(connector, points, segmentElement);
    setElementStype(connector, segmentElement);
    return segmentElement;
  }
  /** @private */


  function updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {
    var getPath;
    var angle;
    element.offsetX = pt.x;
    element.offsetY = pt.y;
    angle = sf.drawings.Point.findAngle(pt, adjacentPoint);
    var thickness = obj.thickness <= 5 ? 5 : obj.thickness;
    getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);
    var size = new sf.drawings.Size(thickness * 2, thickness * 2);
    element.transform = sf.drawings.RotateTransform.Self;
    setElementStype(obj, element);
    element.style.fill = obj.fillColor !== 'tranparent' ? obj.fillColor : 'white';
    element.rotateAngle = angle;
    element.data = getPath;
    element.canMeasurePath = true;
    element.width = size.width;
    element.height = size.height;
  }
  /** @private */


  function getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {
    var decEle = new sf.drawings.PathElement();
    updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);
    return decEle;
  }
  /** @private */


  function clipDecorators(connector, pts) {
    pts[0] = clipDecorator(connector, pts, true);
    pts[pts.length - 1] = clipDecorator(connector, pts, false);
    return pts;
  }
  /** @private */


  function clipDecorator(connector, points, isSource) {
    var point = {
      x: 0,
      y: 0
    };
    var start = {
      x: 0,
      y: 0
    };
    var end = {
      x: 0,
      y: 0
    };
    var length = points.length;
    start = !isSource ? points[length - 1] : points[0];
    end = !isSource ? points[length - 2] : points[1];
    var len = sf.drawings.Point.distancePoints(start, end);
    len = len === 0 ? 1 : len;
    var width = connector.thickness;
    point.x = Math.round(start.x + width * (end.x - start.x) / len);
    point.y = Math.round(start.y + width * (end.y - start.y) / len);
    var strokeWidth = 1;
    point = sf.drawings.Point.adjustPoint(point, end, true, strokeWidth / 2);
    return point;
  }
  /**
   * @hidden
   */
  // tslint:disable-next-line:max-line-length


  function initDistanceLabel(obj, points, measure, pdfviewer) {
    var labels = [];
    var textele;
    var angle = sf.drawings.Point.findAngle(points[0], points[1]);
    textele = textElement(obj, angle);

    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {
      textele.content = obj.notes;
    } else {
      textele.content = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);
    }

    textele.rotateValue = {
      y: -10,
      angle: angle
    };

    if (obj.enableShapeLabel === true) {
      textele.style.strokeColor = obj.labelBorderColor;
      textele.style.fill = obj.labelFillColor;
      textele.style.fontSize = obj.fontSize;
      textele.style.color = obj.fontColor;
      textele.style.fontFamily = obj.fontFamily;
    }

    labels.push(textele);
    return labels;
  }
  /**
   * @hidden
   */


  function updateDistanceLabel(obj, points, measure) {
    var distance;

    for (var i = 0; i < obj.wrapper.children.length; i++) {
      var textElement_1 = obj.wrapper.children[i];

      if (textElement_1 && !sf.base.isNullOrUndefined(textElement_1.content)) {
        distance = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);
        textElement_1.content = distance;
        textElement_1.childNodes[0].text = textElement_1.content;
        textElement_1.refreshTextElement();
      }
    }

    return distance;
  }
  /**
   * @hidden
   */


  function updateRadiusLabel(obj, measure) {
    var radius;

    for (var i = 0; i < obj.wrapper.children.length; i++) {
      var textElement_2 = obj.wrapper.children[i];

      if (textElement_2 && !sf.base.isNullOrUndefined(textElement_2.content)) {
        radius = measure.setConversion(obj.bounds.width / 2 * measure.pixelToPointFactor, obj);
        textElement_2.content = radius;

        if (textElement_2.childNodes.length === 2) {
          textElement_2.childNodes[0].text = radius;
          textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);
        } else {
          textElement_2.childNodes[0].text = radius;
        }

        textElement_2.refreshTextElement();
      }
    }

    return radius;
  }
  /**
   * @hidden
   */
  // tslint:disable-next-line:max-line-length


  function initPerimeterLabel(obj, points, measure, pdfviewer) {
    var labels = [];
    var textele;
    var angle = sf.drawings.Point.findAngle(points[0], points[1]);
    textele = textElement(obj, angle);

    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {
      textele.content = obj.notes;
    } else {
      textele.content = measure.calculatePerimeter(obj);
    }

    if (obj.enableShapeLabel === true) {
      textele.style.strokeColor = obj.labelBorderColor;
      textele.style.fill = obj.labelFillColor;
      textele.style.fontSize = obj.fontSize;
      textele.style.color = obj.fontColor;
      textele.style.fontFamily = obj.fontFamily;
    }

    textele.rotateValue = {
      y: -10,
      angle: angle
    };
    labels.push(textele);
    return labels;
  }
  /**
   * @hidden
   */


  function updatePerimeterLabel(obj, points, measure) {
    var perimeter;

    for (var i = 0; i < obj.wrapper.children.length; i++) {
      var textElement_3 = obj.wrapper.children[i];

      if (textElement_3 && !sf.base.isNullOrUndefined(textElement_3.content)) {
        perimeter = measure.calculatePerimeter(obj);
        textElement_3.content = perimeter;
        textElement_3.childNodes[0].text = textElement_3.content;
        textElement_3.refreshTextElement();
      }
    }

    return perimeter;
  }
  /**
   * @hidden
   */


  function removePerimeterLabel(obj) {
    for (var i = 0; i < obj.wrapper.children.length; i++) {
      var textElement_4 = obj.wrapper.children[i];

      if (textElement_4 && !sf.base.isNullOrUndefined(textElement_4.content)) {
        obj.wrapper.children.splice(i, 1);
      }
    }
  }
  /**
   * @hidden
   */


  function updateCalibrateLabel(obj) {
    if (obj.wrapper && obj.wrapper.children) {
      for (var i = 0; i < obj.wrapper.children.length; i++) {
        var textElement_5 = obj.wrapper.children[i];

        if (textElement_5 && !sf.base.isNullOrUndefined(textElement_5.content)) {
          textElement_5.content = obj.notes;
          textElement_5.childNodes[0].text = textElement_5.content;
          textElement_5.refreshTextElement();
        }
      }
    }
  }
  /**
   * Used to find the path for polygon shapes
   * @hidden
   */


  function getPolygonPath(collection) {
    var path = '';
    var seg;
    path = 'M' + collection[0].x + ' ' + collection[0].y;
    var i;

    for (i = 1; i < collection.length; i++) {
      seg = collection[i];
      path += 'L' + seg.x + ' ' + seg.y;
    }

    path += 'Z';
    return path;
  }
  /**
   * @hidden
   */


  function textElement(obj, angle) {
    var textele = new sf.drawings.TextElement();
    setElementStype(obj, textele);
    textele.style.fill = 'transparent';
    textele.id = sf.drawings.randomId();
    textele.horizontalAlignment = 'Center';
    textele.rotateValue = {
      y: 10,
      angle: angle
    };
    textele.verticalAlignment = 'Top';
    textele.relativeMode = 'Object';
    textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');
    textele.rotateAngle = angle; // tslint:disable-next-line

    textele.style.textWrapping = 'NoWrap';
    return textele;
  }
  /**
   * @hidden
   */


  function initLeaders(obj, points) {
    var leaders = [];
    var leader = initLeader(obj, points[0], points[1]);
    leaders.push(leader);
    leader = initLeader(obj, points[1], points[0], true);
    leaders.push(leader);
    return leaders;
  }
  /**
   * @hidden
   */


  function initLeader(obj, point1, point2, isSecondLeader) {
    var element = new sf.drawings.PathElement();
    element.offsetX = point1.x;
    element.offsetY = point1.y;
    var angle = sf.drawings.Point.findAngle(point1, point2);
    var center = {
      x: (point1.x + point2.x) / 2,
      y: (point1.y + point2.y) / 2
    };
    var getPath;
    var matrix = sf.drawings.identityMatrix();
    sf.drawings.rotateMatrix(matrix, 0 - angle, center.x, center.y);
    var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, point1);
    var newPoint1 = {
      x: rotatedPoint.x,
      y: rotatedPoint.y - obj.leaderHeight
    };
    matrix = sf.drawings.identityMatrix();
    sf.drawings.rotateMatrix(matrix, angle, element.offsetX, element.offsetY);
    rotatedPoint = sf.drawings.transformPointByMatrix(matrix, newPoint1);
    var finalPoint = {
      x: point1.x,
      y: point1.y
    };
    element.offsetX = finalPoint.x;
    element.offsetY = finalPoint.y;
    element.transform = sf.drawings.RotateTransform.Self;
    getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';
    var size = new sf.drawings.Size(0, obj.leaderHeight);
    element.pivot.x = .5;

    if (isSecondLeader) {
      element.id = 'leader2_' + sf.drawings.randomId();
      element.pivot.y = 0;
    } else {
      element.id = 'leader1_' + sf.drawings.randomId();
      element.pivot.y = 1;
    }

    setElementStype(obj, element);
    element.rotateAngle = angle;
    element.data = getPath;
    element.canMeasurePath = true;
    element.width = size.width;
    element.height = size.height;
    return element;
  }
  /** @private */


  function isPointOverConnector(connector, reference) {
    var vertexPoints = connector.vertexPoints;

    for (var i = 0; i < vertexPoints.length - 1; i++) {
      var start = vertexPoints[i];
      var end = vertexPoints[i + 1];
      var rect = sf.drawings.Rect.toBounds([start, end]);
      rect.Inflate(10);

      if (rect.containsPoint(reference)) {
        var intersectinPt = findNearestPoint(reference, start, end);
        var segment1 = {
          x1: start.x,
          x2: end.x,
          y1: start.y,
          y2: end.y
        };
        var segment2 = {
          x1: reference.x,
          x2: intersectinPt.x,
          y1: reference.y,
          y2: intersectinPt.y
        };
        var intersectDetails = sf.drawings.intersect3(segment1, segment2);

        if (intersectDetails.enabled) {
          var distance = sf.drawings.Point.findLength(reference, intersectDetails.intersectPt);

          if (Math.abs(distance) < 10) {
            return true;
          }
        } else {
          var rect_1 = sf.drawings.Rect.toBounds([reference, reference]);
          rect_1.Inflate(3);

          if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {
            return true;
          }
        }

        if (sf.drawings.Point.equals(reference, intersectinPt)) {
          return true;
        }
      }
    }

    return false;
  }
  /** @private */


  function findNearestPoint(reference, start, end) {
    var shortestPoint;
    var shortest = sf.drawings.Point.findLength(start, reference);
    var shortest1 = sf.drawings.Point.findLength(end, reference);

    if (shortest > shortest1) {
      shortestPoint = end;
    } else {
      shortestPoint = start;
    }

    var angleBWStAndEnd = sf.drawings.Point.findAngle(start, end);
    var angleBWStAndRef = sf.drawings.Point.findAngle(shortestPoint, reference);
    var r = sf.drawings.Point.findLength(shortestPoint, reference);
    var vaAngle = angleBWStAndRef + (angleBWStAndEnd - angleBWStAndRef) * 2;
    return {
      x: shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180),
      y: shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180)
    };
  }
  /**
   * @hidden
   */


  function getDecoratorShape(shape) {
    // tslint:disable-next-line
    return decoratorShapes[shape];
  }

  var decoratorShapes = {
    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',
    'Square': 'M0,0 L10,0 L10,10 L0,10 z',
    'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',
    'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' + 'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' + 'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' + 'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',
    'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',
    'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',
    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',
    'Arrow': 'M15,10 L15,22 L5,16Z',
    'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',
    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z'
  }; // tslint:disable-next-line:max-line-length
  // tslint:disable-next-line:max-line-length

  /**
   * Renderer module is used to render basic diagram elements
   * @hidden
   */

  var Drawing =
  /** @class */
  function () {
    function Drawing(viewer) {
      this.isDynamicStamps = false;
      this.pdfViewer = viewer;
      this.renderer = new sf.drawings.DrawingRenderer('this.pdfViewer.element.id', false);
      this.svgRenderer = new sf.drawings.SvgRenderer();
    }
    /**
     * @private
     */


    Drawing.prototype.renderLabels = function (viewer) {
      var annotations = viewer.annotations;

      if (annotations) {
        for (var i = 0; i < annotations.length; i++) {
          var annotation = annotations[i];
          this.initObject(annotation);
        }
      }
    };

    Drawing.prototype.createNewZindexTable = function (pageId) {
      var zIndexTable = new ZOrderPageTable();
      this.pdfViewer.zIndex++;
      zIndexTable.pageId = this.pdfViewer.zIndex;
      this.pdfViewer.zIndexTable.push(zIndexTable);
      return zIndexTable;
    };
    /**
     * @private
     */


    Drawing.prototype.getPageTable = function (pageId) {
      var zIndexTable;

      if (this.pdfViewer.zIndexTable.length !== undefined) {
        var notFound = true;

        for (var i = 0; i < this.pdfViewer.zIndexTable.length; i++) {
          if (this.pdfViewer.zIndexTable[i].pageId === pageId) {
            notFound = false;
            zIndexTable = this.pdfViewer.zIndexTable[i];
            break;
          }
        }

        if (notFound) {
          zIndexTable = this.createNewZindexTable(pageId);
          zIndexTable.pageId = pageId;
        }
      } else {
        zIndexTable = this.createNewZindexTable(pageId);
      }

      return zIndexTable;
    };
    /**
     * @private
     */


    Drawing.prototype.setZIndex = function (index, obj) {
      if (obj.pageIndex !== undefined) {
        var pageTable = this.getPageTable(obj.pageIndex);

        if (obj.zIndex === -1) {
          pageTable.zIndex++;
          obj.zIndex = pageTable.zIndex;
          pageTable.objects.push(obj);
        } else {
          var index_1 = obj.zIndex;
          var tabelLength = pageTable.objects.length;
          obj.zIndex = tabelLength++;
          pageTable.objects.push(obj);
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.initObject = function (obj) {
      //Move the common properties like zindex and id to an abstract class
      this.setZIndex(this.pdfViewer.zIndex, obj);
      sf.drawings.createMeasureElements();

      if (!isLineShapes(obj)) {
        this.initNode(obj);
      } else {
        this.initLine(obj);
        obj.wrapper.measure(new sf.drawings.Size(undefined, undefined));
        obj.wrapper.arrange(obj.wrapper.desiredSize);
      }

      if (obj.wrapper === null) {//Init default wrapper
      } // tslint:disable-next-line:no-any


      this.pdfViewer.nameTable[obj.id] = obj; //Add some methodologies to add the children of group to name table

      return obj;
    };

    Drawing.prototype.initNode = function (obj) {
      var canvas = this.initContainer(obj);
      var content;

      if (!canvas.children) {
        canvas.children = [];
      }

      if (!content) {
        content = this.init(obj, canvas);
      } //canvas.children.push(content);


      canvas.rotateAngle = obj.rotateAngle;
      canvas.measure(new sf.drawings.Size(obj.wrapper.width, obj.wrapper.height));
      canvas.arrange(canvas.desiredSize);

      if (this.isDynamicStamps) {
        this.pdfViewer.annotation.stampAnnotationModule.updateSessionStorage(obj, null, 'dynamicStamp');
        this.isDynamicStamps = false;
      }
    };
    /**
     * Allows to initialize the UI of a node
     */

    /**
     * @private
     */

    /* tslint:disable */


    Drawing.prototype.init = function (obj, canvas) {
      var content;
      content = new sf.drawings.DrawingElement();
      var pathContent;
      var basicElement;
      var isStamp = false; // tslint:disable-next-line

      var annotationSettings = this.pdfViewer.annotationModule.findAnnotationSettings(obj);
      var annotationMaxHeight = 0;
      var annotationMaxWidth = 0;
      var annotationMinHeight = 0;
      var annotationMinWidth = 0;

      if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {
        annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
        annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;
        annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;
        annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;
      }

      var isAnnotationSet = false;

      if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {
        isAnnotationSet = true;
      }

      switch (obj.shapeAnnotationType) {
        case 'Ellipse':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = 'M80.5,12.5 C80.5,19.127417 62.59139,24.5 40.5,24.5 C18.40861,24.5 0.5,19.127417 0.5,12.5' + 'C0.5,5.872583 18.40861,0.5 40.5,0.5 C62.59139,0.5 80.5,5.872583 80.5,12.5 z';
          content = pathContent;
          canvas.children.push(content);

          if (obj.enableShapeLabel) {
            var textLabel = this.textElement(obj);
            textLabel.content = obj.labelContent;
            textLabel.style.color = obj.fontColor;
            textLabel.style.strokeColor = obj.labelBorderColor;
            textLabel.style.fill = obj.labelFillColor;
            textLabel.style.fontSize = obj.fontSize;
            textLabel.style.fontFamily = obj.fontFamily;
            textLabel.style.opacity = obj.labelOpacity;
            canvas.children.push(textLabel);
          }

          break;

        case 'Path':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = obj.data;
          content = pathContent;
          canvas.children.push(content);
          break;

        case 'HandWrittenSignature':
        case 'Ink':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = obj.data;
          pathContent.style.strokeColor = obj.strokeColor;
          pathContent.style.strokeWidth = obj.thickness;
          pathContent.style.opacity = obj.opacity;
          content = pathContent;
          canvas.children.push(content);
          break;

        case 'Polygon':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = getPolygonPath(obj.vertexPoints);
          content = pathContent;
          canvas.children.push(content);
          break;

        case 'Stamp':
          isStamp = true;
          this.isDynamicStamps = true;

          if (obj && obj.annotationAddMode && obj.annotationAddMode === 'Existing Annotation') {
            obj.bounds.width = obj.bounds.width - 20;
            obj.bounds.height = obj.bounds.height - 20;
          }

          if (obj.isDynamicStamp) {
            canvas.horizontalAlignment = 'Left';
            basicElement = new sf.drawings.DrawingElement();
            content = basicElement;
            content.cornerRadius = 10;
            content.style.fill = obj.stampFillColor;
            content.style.strokeColor = obj.stampStrokeColor;
            canvas.children.push(content);
            var textele_1 = this.textElement(obj);
            textele_1 = new sf.drawings.TextElement();
            textele_1.style.fontFamily = 'Helvetica';
            textele_1.style.fontSize = 14;
            textele_1.style.italic = true;
            textele_1.style.bold = true;
            textele_1.style.color = obj.fillColor;
            textele_1.rotateValue = undefined;
            textele_1.content = obj.dynamicText;
            textele_1.relativeMode = 'Point';
            textele_1.margin.left = 10;
            textele_1.margin.bottom = -7;
            textele_1.setOffsetWithRespectToBounds(0, 0.57, null);
            textele_1.relativeMode = 'Point';
            canvas.children.push(textele_1); // tslint:disable-next-line

            var pathContent1 = new sf.drawings.PathElement();
            pathContent1.id = sf.drawings.randomId() + '_stamp';
            pathContent1.data = obj.data;
            pathContent1.width = obj.bounds.width;

            if (isAnnotationSet && obj.bounds.width > annotationMaxWidth) {
              pathContent1.width = annotationMaxWidth;
              obj.bounds.width = annotationMaxWidth;
            }

            pathContent1.height = obj.bounds.height / 2;

            if (isAnnotationSet && obj.bounds.height > annotationMaxHeight) {
              pathContent1.height = annotationMaxHeight / 2;
              obj.bounds.height = annotationMaxHeight / 2;
            }

            pathContent1.rotateValue = undefined;
            pathContent1.margin.left = 10;
            pathContent1.margin.bottom = -5;
            pathContent1.relativeMode = 'Point';
            pathContent1.setOffsetWithRespectToBounds(0, 0.1, null); // tslint:disable-next-line

            var content1 = pathContent1;
            pathContent1.style.fill = obj.fillColor;
            pathContent1.style.strokeColor = obj.strokeColor;
            pathContent1.style.opacity = obj.opacity;
            content.width = obj.bounds.width + 20;
            content.height = obj.bounds.height + 20;
            content.style.opacity = obj.opacity;
            canvas.children.push(content1);
          } else {
            canvas.horizontalAlignment = 'Left';
            basicElement = new sf.drawings.DrawingElement();
            content = basicElement;
            content.cornerRadius = 10;
            content.style.fill = obj.stampFillColor;
            content.style.strokeColor = obj.stampStrokeColor;
            canvas.children.push(content); // tslint:disable-next-line

            var pathContent1 = new sf.drawings.PathElement();
            pathContent1.id = sf.drawings.randomId() + '_stamp';
            pathContent1.data = obj.data;
            pathContent1.width = obj.bounds.width;

            if (isAnnotationSet && obj.bounds.width > annotationMaxWidth) {
              pathContent1.width = annotationMaxWidth;
              obj.bounds.width = annotationMaxWidth;
            }

            pathContent1.height = obj.bounds.height;

            if (isAnnotationSet && obj.bounds.height > annotationMaxHeight) {
              pathContent1.height = annotationMaxHeight;
              obj.bounds.height = annotationMaxHeight;
            }

            pathContent1.minWidth = pathContent1.width / 2;
            pathContent1.minHeight = pathContent1.height / 2; // tslint:disable-next-line

            var content1 = pathContent1;
            pathContent1.style.fill = obj.fillColor;
            pathContent1.style.strokeColor = obj.strokeColor;
            pathContent1.style.opacity = obj.opacity;
            content.width = obj.bounds.width + 20;
            content.height = obj.bounds.height + 20;
            content.minWidth = pathContent1.width / 2;
            content.minHeight = pathContent1.height / 2;
            content.style.opacity = obj.opacity;
            canvas.children.push(content1);
            canvas.minHeight = content.minHeight + 20;
            canvas.minWidth = content.minWidth + 20;
          }

          if (obj && obj.annotationAddMode && obj.annotationAddMode === 'Existing Annotation') {
            obj.bounds.width = obj.bounds.width + 20;
            obj.bounds.height = obj.bounds.height + 20;
          }

          break;

        case 'Image':
          // tslint:disable-next-line
          var pathContent11 = new sf.drawings.ImageElement();
          pathContent11.source = obj.data;
          content = pathContent11;
          canvas.children.push(content);
          break;

        case 'Rectangle':
          basicElement = new sf.drawings.DrawingElement();
          content = basicElement;
          canvas.children.push(content);

          if (obj.enableShapeLabel) {
            var textLabel = this.textElement(obj);
            textLabel.content = obj.labelContent;
            textLabel.style.color = obj.fontColor;
            textLabel.style.strokeColor = obj.labelBorderColor;
            textLabel.style.fill = obj.labelFillColor;
            textLabel.style.fontSize = obj.fontSize;
            textLabel.style.fontFamily = obj.fontFamily;
            textLabel.style.opacity = obj.labelOpacity;
            canvas.children.push(textLabel);
          }

          break;

        case 'Perimeter':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = 'M80.5,12.5 C80.5,19.127417 62.59139,24.5 40.5,24.5 C18.40861,24.5 0.5,19.127417 0.5,12.5' + 'C0.5,5.872583 18.40861,0.5 40.5,0.5 C62.59139,0.5 80.5,5.872583 80.5,12.5 z';
          content = pathContent;
          setElementStype(obj, pathContent);
          canvas.children.push(content);
          basicElement = new sf.drawings.DrawingElement();
          basicElement.id = 'perimeter_' + sf.drawings.randomId();
          basicElement.height = .2;
          basicElement.width = .2;
          basicElement.transform = sf.drawings.RotateTransform.Self;
          basicElement.horizontalAlignment = 'Stretch';
          this.setNodePosition(basicElement, obj);
          basicElement.rotateAngle = obj.rotateAngle;
          setElementStype(obj, basicElement);
          canvas.children.push(basicElement);
          var textele = this.textElement(obj);
          textele = new sf.drawings.TextElement();
          textele.content = textele.content = findPointsLength([{
            x: obj.bounds.x,
            y: obj.bounds.y
          }, {
            x: obj.bounds.x + obj.bounds.width,
            y: obj.bounds.y + obj.bounds.height
          }]).toString();
          textele.rotateValue = {
            y: -10,
            angle: obj.rotateAngle
          };
          canvas.children.push(textele);
          break;

        case 'Radius':
          pathContent = new sf.drawings.PathElement();
          pathContent.data = 'M80.5,12.5 C80.5,19.127417 62.59139,24.5 40.5,24.5 C18.40861,24.5 0.5,19.127417 0.5,12.5' + 'C0.5,5.872583 18.40861,0.5 40.5,0.5 C62.59139,0.5 80.5,5.872583 80.5,12.5 z';
          content = pathContent;
          setElementStype(obj, pathContent);
          canvas.children.push(content);
          basicElement = new sf.drawings.DrawingElement();
          basicElement.id = 'radius_' + sf.drawings.randomId();
          basicElement.height = .2;
          basicElement.width = obj.bounds.width / 2;
          basicElement.transform = sf.drawings.RotateTransform.Self;
          this.setNodePosition(basicElement, obj);
          basicElement.rotateAngle = obj.rotateAngle;
          setElementStype(obj, basicElement);
          canvas.children.push(basicElement);
          textele = this.textElement(obj);

          if (obj.enableShapeLabel) {
            textele.style.color = obj.fontColor;
            textele.style.strokeColor = obj.labelBorderColor;
            textele.style.fill = obj.labelFillColor;
            textele.style.fontSize = obj.fontSize;
            textele.style.fontFamily = obj.fontFamily;
            textele.style.opacity = obj.labelOpacity;
          }

          var length_1 = findPointsLength([{
            x: obj.bounds.x,
            y: obj.bounds.y
          }, {
            x: obj.bounds.x + obj.bounds.width,
            y: obj.bounds.y + obj.bounds.height
          }]);

          if (!this.pdfViewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {
            textele.content = obj.notes;
          } else {
            // tslint:disable-next-line:max-line-length
            textele.content = this.pdfViewer.annotation.measureAnnotationModule.setConversion(length_1 / 2 * this.pdfViewer.annotation.measureAnnotationModule.pixelToPointFactor, obj);
          }

          textele.rotateValue = {
            y: -10,
            x: obj.bounds.width / 4,
            angle: obj.rotateAngle
          };
          canvas.children.push(textele);
          break;

        case 'StickyNotes':
          // tslint:disable-next-line
          var pathContent2 = new sf.drawings.ImageElement();
          pathContent2.source = obj.data;
          pathContent2.width = obj.bounds.width;
          pathContent2.height = obj.bounds.height;
          pathContent2.style.strokeColor = obj.strokeColor;
          pathContent2.style.strokeWidth = 0;
          content = pathContent2;
          canvas.children.push(content);
          break;

        case 'FreeText':
          // tslint:disable-next-line
          var rectElement = new sf.drawings.DrawingElement();
          content = rectElement;
          canvas.children.push(content);
          var freeTextEle = this.textElement(obj);
          freeTextEle = new sf.drawings.TextElement();
          freeTextEle.style.fontFamily = obj.fontFamily;
          freeTextEle.style.fontSize = obj.fontSize;
          freeTextEle.style.textAlign = 'Left';

          if (obj.textAlign.toLowerCase() === 'center') {
            freeTextEle.style.textAlign = 'Center';
          } else if (obj.textAlign.toLowerCase() === 'right') {
            freeTextEle.style.textAlign = 'Right';
          } else if (obj.textAlign.toLowerCase() === 'justify') {
            freeTextEle.style.textAlign = 'Justify';
          }

          freeTextEle.style.color = obj.fontColor;
          freeTextEle.style.bold = obj.font.isBold;
          freeTextEle.style.italic = obj.font.isItalic;

          if (obj.font.isUnderline === true) {
            freeTextEle.style.textDecoration = 'Underline';
          } else if (obj.font.isStrikeout === true) {
            freeTextEle.style.textDecoration = 'LineThrough';
          }

          freeTextEle.rotateValue = undefined;
          freeTextEle.content = obj.dynamicText;
          freeTextEle.margin.left = 2;
          freeTextEle.margin.top = 5;
          freeTextEle.style.textWrapping = 'Wrap';
          freeTextEle.relativeMode = 'Point';
          freeTextEle.setOffsetWithRespectToBounds(0, 0, null);
          freeTextEle.relativeMode = 'Point';
          canvas.children.push(freeTextEle);
          break;
      }

      content.id = obj.id + '_content';
      content.relativeMode = 'Object';

      if (!isStamp) {
        if (obj.bounds.width !== undefined) {
          content.width = obj.bounds.width;

          if (isAnnotationSet) {
            if (content.width < annotationMinWidth || content.width > annotationMaxWidth) {
              if (content.width < annotationMinWidth) {
                content.width = annotationMinWidth;
              }

              if (content.width > annotationMaxWidth) {
                content.width = annotationMaxWidth;
              }
            }
          }
        }

        content.horizontalAlignment = 'Stretch';

        if (obj.bounds.height !== undefined) {
          content.height = obj.bounds.height;

          if (isAnnotationSet) {
            if (content.height < annotationMinHeight || content.width > annotationMaxHeight) {
              if (content.height < annotationMinHeight) {
                content.height = annotationMinHeight;
              }

              if (content.height > annotationMaxHeight) {
                content.height = annotationMaxHeight;
              }
            }
          }
        }

        setElementStype(obj, content);
      }

      content.isRectElement = true;
      content.verticalAlignment = 'Stretch';
      return content;
    };

    Drawing.prototype.textElement = function (obj) {
      var textele = new sf.drawings.TextElement();
      setElementStype(obj, textele);
      textele.horizontalAlignment = 'Center';
      textele.verticalAlignment = 'Top';
      textele.relativeMode = 'Object';
      textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');
      return textele;
    };
    /**
     * @private
     */


    Drawing.prototype.setNodePosition = function (obj, node) {
      if (node.shapeAnnotationType === 'Perimeter') {
        obj.offsetX = node.bounds.x + node.bounds.width / 2;
        obj.offsetY = node.bounds.y + node.bounds.height / 2;
      } else if (node.shapeAnnotationType === 'Radius') {
        // tslint:disable-next-line:max-line-length
        var trasPoint = {
          x: node.bounds.x + node.bounds.width / 2 + node.bounds.width / 4,
          y: node.bounds.y + node.bounds.height / 2
        };
        var center = {
          x: node.bounds.x + node.bounds.width / 2,
          y: node.bounds.y + node.bounds.height / 2
        };
        var matrix = sf.drawings.identityMatrix();
        sf.drawings.rotateMatrix(matrix, node.rotateAngle, center.x, center.y);
        var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, trasPoint);
        var newPoint1 = {
          x: rotatedPoint.x,
          y: rotatedPoint.y
        };
        obj.offsetX = newPoint1.x;
        obj.offsetY = newPoint1.y;
        obj.width = node.bounds.width / 2;
      }
    };
    /* tslint:enable */

    /**
     * @private
     */


    Drawing.prototype.initContainer = function (obj) {
      if (!obj.id) {
        obj.id = sf.drawings.randomId();
      } // Creates canvas element


      var canvas;
      canvas = new sf.drawings.Canvas();
      canvas.id = obj.id;
      canvas.offsetX = obj.bounds.x + obj.bounds.width * 0.5;
      canvas.offsetY = obj.bounds.y + obj.bounds.height * 0.5;
      canvas.style.fill = 'transparent';
      canvas.style.strokeColor = 'transparent';
      canvas.rotateAngle = obj.rotateAngle;
      obj.wrapper = canvas;
      return canvas;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:no-any


    Drawing.prototype.initLine = function (obj) {
      if (!obj.id) {
        obj.id = sf.drawings.randomId();
      }

      var container = new sf.drawings.Canvas();
      var segment = new sf.drawings.PathElement();
      segment.id = obj.id + '_path';
      var srcDecorator = new sf.drawings.PathElement();
      var targetDecorator = new sf.drawings.PathElement();

      if (obj.vertexPoints.length) {
        obj.sourcePoint = obj.vertexPoints[0];
        obj.targetPoint = obj.vertexPoints[obj.vertexPoints.length - 1];

        for (var i = 0; i < obj.vertexPoints.length; i++) {
          if (i !== 0 && i !== obj.vertexPoints.length - 1) {
            obj.segments.push(obj.vertexPoints[i]);
          }
        }
      }

      segment = getSegmentElement(obj, segment);
      var bounds;
      var points = [];
      points = getConnectorPoints(obj); //  points = this.clipDecorators(this, points);

      var leaders = [];
      var labels = [];

      if (obj.shapeAnnotationType === 'Distance') {
        leaders = initLeaders(obj, points);
        labels = initDistanceLabel(obj, points, this.pdfViewer.annotation.measureAnnotationModule, this.pdfViewer);
      }

      if ((obj.shapeAnnotationType === 'Line' || obj.shapeAnnotationType === 'LineWidthArrowHead') && obj.measureType === 'Perimeter') {
        labels = initPerimeterLabel(obj, points, this.pdfViewer.annotation.measureAnnotationModule, this.pdfViewer);
      }

      if (obj.enableShapeLabel === true && !(obj.shapeAnnotationType === 'Distance') && !(obj.measureType === 'Perimeter')) {
        var textele = void 0;
        var angle = sf.drawings.Point.findAngle(points[0], points[1]);
        textele = this.textElement(obj);
        textele.id = sf.drawings.randomId();

        if (!this.pdfViewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {
          textele.content = obj.notes;
        } else {
          textele.content = obj.labelContent;
        }

        textele.style.strokeColor = obj.labelBorderColor;
        textele.style.fill = obj.labelFillColor;
        textele.style.fontSize = obj.fontSize;
        textele.style.color = obj.fontColor;
        textele.style.fontFamily = obj.fontFamily;
        textele.style.opacity = obj.labelOpacity;
        textele.rotateValue = {
          y: -10,
          angle: angle
        };
        labels.push(textele);
      }

      points = clipDecorators(obj, points);
      bounds = sf.drawings.Rect.toBounds(points);
      container.width = bounds.width;
      container.height = bounds.height;
      container.offsetX = bounds.x + container.pivot.x * bounds.width;
      container.offsetY = bounds.y + container.pivot.y * bounds.height;
      var anglePoints = obj.vertexPoints;

      if (obj.shapeAnnotationType === 'Line' || obj.shapeAnnotationType === 'LineWidthArrowHead' || obj.shapeAnnotationType === 'Distance') {
        srcDecorator = getDecoratorElement(obj, points[0], anglePoints[1], true);
        targetDecorator = getDecoratorElement(obj, points[points.length - 1], anglePoints[anglePoints.length - 2], false);
      }

      srcDecorator.id = obj.id + '_srcDec';
      targetDecorator.id = obj.id + '_tarDec';
      /* tslint:disable:no-string-literal */

      segment.style['fill'] = 'transparent';
      container.style.strokeColor = 'transparent';
      container.style.fill = 'transparent';
      container.style.strokeWidth = 0;
      container.children = [];
      setElementStype(obj, segment);
      container.children.push(segment);

      if (leaders.length > 0) {
        for (var i = 0; i < leaders.length; i++) {
          container.children.push(leaders[i]);
        }
      }

      if (labels.length > 0) {
        for (var i = 0; i < labels.length; i++) {
          container.children.push(labels[i]);
        }
      }

      container.children.push(srcDecorator);
      container.children.push(targetDecorator);
      container.id = obj.id;
      container.offsetX = segment.offsetX;
      container.offsetY = segment.offsetY;
      container.width = segment.width;
      container.height = segment.height;
      points = getConnectorPoints(obj);
      obj.wrapper = container;
      return container;
    };
    /**
     * @private
     */


    Drawing.prototype.add = function (obj) {
      obj = new PdfAnnotationBase(this.pdfViewer, 'annotations', obj, true);
      obj = this.initObject(obj);
      this.pdfViewer.annotations.push(obj);
      return obj;
    };
    /**
     * @private
     */


    Drawing.prototype.remove = function (obj) {
      var index = obj.pageIndex;

      for (var i = 0; i < this.pdfViewer.annotations.length; i++) {
        var annotation = this.pdfViewer.annotations[i];

        if (annotation.id === obj.id || annotation.wrapper.id === obj.id) {
          this.pdfViewer.annotations.splice(i, 1);
          var objects = this.getPageObjects(obj.pageIndex);

          for (var j = 0; j < objects.length; j++) {
            if (objects[j].id === obj.id) {
              objects.splice(j, 1);
            }
          } // need to add code snippet to remove from z index table

        }
      }

      this.pdfViewer.renderDrawing(undefined, index);
    };
    /**
     * @private
     */


    Drawing.prototype.getPageObjects = function (pageIndex) {
      var pageTable = this.getPageTable(pageIndex);
      return pageTable.objects;
    };
    /**
     * @private
     */


    Drawing.prototype.refreshCanvasDiagramLayer = function (diagramLayer, pageIndex) {
      if (!diagramLayer) {
        diagramLayer = document.getElementById(this.pdfViewer.element.id + '_annotationCanvas_' + pageIndex);
      }

      if (diagramLayer) {
        var width = diagramLayer.width / this.pdfViewer.viewerBase.getZoomFactor();
        var height = diagramLayer.height / this.pdfViewer.viewerBase.getZoomFactor();
        var zoom = this.pdfViewer.viewerBase.getZoomFactor();
        var ctx = diagramLayer.getContext('2d');
        ctx.setTransform(zoom, 0, 0, zoom, 0, 0);
        ctx.clearRect(0, 0, width, height);
        var objects = this.getPageObjects(pageIndex);

        for (var i = 0; i < objects.length; i++) {
          // tslint:disable-next-line:no-any
          var renderElement = this.pdfViewer.nameTable[objects[i].id].wrapper;
          sf.drawings.refreshDiagramElements(diagramLayer, [renderElement], this.renderer);
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.clearHighlighter = function (index) {
      var adornerSvg = this.getAdornerLayerSvg(this.pdfViewer.element.id + index + '_diagramAdornerLayer', index);

      if (adornerSvg) {
        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_highlighter');

        if (highlighter) {
          highlighter.parentNode.removeChild(highlighter);
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.getSelectorElement = function (diagramId, index) {
      var adornerLayer = null;
      var adornerSvg = this.getAdornerLayerSvg(diagramId, index);

      if (adornerSvg) {
        adornerLayer = adornerSvg.getElementById(diagramId + '_SelectorElement');
      }

      return adornerLayer;
    };
    /**
     * @private
     */


    Drawing.prototype.getAdornerLayerSvg = function (diagramId, index) {
      var adornerLayerSvg = null;
      var diagramElement = sf.drawings.getDiagramElement(diagramId + index + '_diagramAdornerLayer');
      var elementcoll;

      if (diagramElement) {
        elementcoll = diagramElement.getElementsByClassName('e-adorner-layer' + index);
        adornerLayerSvg = elementcoll[0];
      }

      return adornerLayerSvg;
    };
    /**
     * @private
     */


    Drawing.prototype.clearSelectorLayer = function (index) {
      var adornerSvg = this.getAdornerLayerSvg(this.pdfViewer.element.id, index);

      if (adornerSvg) {
        var selectionRect = adornerSvg.getElementById(this.pdfViewer.adornerSvgLayer.id + '_selected_region');

        if (selectionRect) {
          selectionRect.parentNode.removeChild(selectionRect);
        }

        this.clearHighlighter(index);
        var childNodes = this.getSelectorElement(this.pdfViewer.element.id, index).childNodes;
        var child = void 0;

        for (var i = childNodes.length; i > 0; i--) {
          child = childNodes[i - 1];
          child.parentNode.removeChild(child);
        }
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length


    Drawing.prototype.renderSelector = function (select, currentSelector, helper, isSelect) {
      if (!helper || isSelect) {
        var size = new sf.drawings.Size();
        var selectorModel = this.pdfViewer.selectedItems;
        this.clearSelectorLayer(select);

        if (selectorModel.wrapper) {
          selectorModel.wrapper.measure(size);
          var zoom = this.pdfViewer.viewerBase.getZoomFactor();
          selectorModel.wrapper.arrange(selectorModel.wrapper.desiredSize);
          selectorModel.width = selectorModel.wrapper.actualSize.width;
          selectorModel.height = selectorModel.wrapper.actualSize.height;
          selectorModel.offsetX = selectorModel.wrapper.offsetX;
          selectorModel.offsetY = selectorModel.wrapper.offsetY;

          if (selectorModel.annotations.length === 1) {
            selectorModel.rotateAngle = selectorModel.annotations[0].rotateAngle;
            selectorModel.wrapper.rotateAngle = selectorModel.annotations[0].rotateAngle; //selectorModel.pivot = selectorModel.annotations[0].pivot;
          }

          var bounds = selectorModel.wrapper.bounds; // tslint:disable-next-line

          var selectorElement = void 0;

          if (selectorModel.annotations.length) {
            for (var j = 0; j < selectorModel.annotations.length; j++) {
              var node = selectorModel.annotations[j];
              selectorElement = this.getSelectorElement(this.pdfViewer.element.id, select);

              if (selectorElement && node.pageIndex === select) {
                if (node.shapeAnnotationType === 'Distance' || node.shapeAnnotationType === 'Line' || node.shapeAnnotationType === 'LineWidthArrowHead' || node.shapeAnnotationType === 'Polygon') {
                  this.renderEndPointHandle(node, selectorElement, selectorModel.thumbsConstraints, {
                    scale: zoom,
                    tx: 0,
                    ty: 0
                  }, undefined, undefined, true, currentSelector);
                } else {
                  if (node.shapeAnnotationType === 'StickyNotes') {
                    this.renderResizeHandle(node.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, zoom, undefined, undefined, undefined, false, true, null, null, currentSelector);
                  } else {
                    if (this.pdfViewer.tool !== 'Stamp') {
                      this.renderResizeHandle(node.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, zoom, // tslint:disable-next-line:max-line-length
                      undefined, undefined, undefined, node.shapeAnnotationType === 'Stamp', false, node.shapeAnnotationType === 'Path', node.shapeAnnotationType === 'FreeText' || node.shapeAnnotationType === 'HandWrittenSignature' || node.shapeAnnotationType === 'Image', currentSelector);
                    }
                  }
                }

                if (!this.pdfViewer.viewerBase.isNewSignatureAdded && node.shapeAnnotationType === 'HandWrittenSignature') {
                  this.pdfViewer.annotationModule.selectSignature(node.signatureName, node.pageIndex, node);
                }

                if (node.annotName !== '') {
                  if (helper && node === helper) {
                    // tslint:disable-next-line:max-line-length
                    if (!this.pdfViewer.viewerBase.isAnnotationSelect && !this.pdfViewer.viewerBase.isAnnotationMouseDown && !this.pdfViewer.viewerBase.isAnnotationMouseMove && !this.pdfViewer.viewerBase.isInkAdded) {
                      this.pdfViewer.viewerBase.isAnnotationSelect = true;
                      this.pdfViewer.annotationModule.annotationSelect(node.annotName, node.pageIndex, node);
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    /**
     * Rotates the given nodes/connectors by the given angle
     * @param obj Defines the objects to be rotated
     * @param angle Defines the angle by which the objects have to be rotated
     * @param pivot Defines the reference point with reference to which the objects have to be rotated
     */

    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length


    Drawing.prototype.rotate = function (obj, angle, pivot, currentSelector) {
      var checkBoundaryConstraints;

      if (obj) {
        pivot = pivot || {
          x: obj.wrapper.offsetX,
          y: obj.wrapper.offsetY
        };

        if (obj instanceof Selector) {
          obj.rotateAngle += angle;
          obj.wrapper.rotateAngle += angle;
          var objects = [];
          objects = objects.concat(obj.annotations);
          this.rotateObjects(obj, objects, angle, pivot, null, currentSelector);
        } else {
          this.rotateObjects(obj, [obj], angle, pivot);
        }
      }

      return checkBoundaryConstraints;
    };
    /**
     * @private
     */


    Drawing.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent, currentSelector) {
      pivot = pivot || {};
      var matrix = sf.drawings.identityMatrix();
      sf.drawings.rotateMatrix(matrix, angle, pivot.x, pivot.y);

      for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
        var obj = objects_1[_i];

        if (obj instanceof PdfAnnotationBase) {
          if (includeParent !== false || parent !== obj) {
            obj.rotateAngle += angle;
            obj.rotateAngle = (obj.rotateAngle + 360) % 360;
            var newOffset = sf.drawings.transformPointByMatrix(matrix, {
              x: obj.wrapper.offsetX,
              y: obj.wrapper.offsetY
            });
            obj.wrapper.offsetX = newOffset.x;
            obj.wrapper.offsetY = newOffset.y;
            this.nodePropertyChange(obj, {
              rotateAngle: obj.rotateAngle
            });
          }

          this.renderSelector(obj.pageIndex, currentSelector);
        }
      }
    };

    Drawing.prototype.getParentSvg = function (element, targetElement, canvas) {
      if (element && element.id) {
        if (targetElement && targetElement === 'selector') {
          return this.pdfViewer.adornerSvgLayer;
        }
      }

      return canvas;
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.renderBorder = function (selector, canvas, currentSelector, transform, enableNode, isBorderTickness, isSwimlane, isSticky) {
      var wrapper = selector;
      var options = getBaseShapeAttributes(wrapper, transform);
      transform = transform || {
        scale: 1,
        tx: 0,
        ty: 0
      };

      if (!isSticky) {
        options.x *= transform.scale;
        options.y *= transform.scale;
        options.width *= transform.scale;
        options.height *= transform.scale;
        options.fill = 'transparent';
        var shapeType = void 0;
        shapeType = this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType;

        if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
          // tslint:disable-next-line
          var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

          var borderColor = annotationSelector.selectionBorderColor === '' ? 'black' : annotationSelector.selectionBorderColor;
          options.stroke = borderColor; // tslint:disable-next-line:max-line-length

          options.strokeWidth = currentSelector.selectionBorderThickness === 1 ? 1 : annotationSelector.selectionBorderThickness;
          var lineDash = annotationSelector.selectorLineDashArray.length === 0 ? [6, 3] : annotationSelector.selectorLineDashArray;

          if (lineDash.length > 2) {
            lineDash = [lineDash[0], lineDash[1]];
          }

          options.dashArray = lineDash.toString();
        } else {
          if (shapeType === 'HandWrittenSignature') {
            this.getSignBorder(shapeType, options);
          } else {
            this.getBorderSelector(shapeType, options);
          }
        }

        options.class = 'e-pv-diagram-border';

        if (isSwimlane) {
          options.class += ' e-diagram-lane';
        }

        options.id = 'borderRect';
        options.id = 'borderRect';

        if (!enableNode) {
          options.class += ' e-disabled';
        }

        if (isBorderTickness) {
          options.class += ' e-thick-border';
        }

        options.cornerRadius = 0;
      } else {
        options.x *= transform.scale;
        options.y *= transform.scale;
        options.width *= transform.scale;
        options.height *= transform.scale;
        var shapeType = void 0;
        shapeType = this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType;

        if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
          var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

          var borderColor = annotationSelector.selectionBorderColor === '' ? 'black' : annotationSelector.selectionBorderColor;
          options.stroke = borderColor; // tslint:disable-next-line:max-line-length

          options.strokeWidth = currentSelector.selectionBorderThickness === 1 ? 1 : annotationSelector.selectionBorderThickness;
          var lineDash = annotationSelector.selectorLineDashArray.length === 0 ? [6, 3] : annotationSelector.selectorLineDashArray;

          if (lineDash.length > 2) {
            lineDash = [lineDash[0], lineDash[1]];
          }

          options.dashArray = lineDash.toString();
        } else {
          this.getBorderSelector(shapeType, options);
        }
      }

      var parentSvg = this.getParentSvg(selector, 'selector'); // tslint:disable-next-line:max-line-length

      this.svgRenderer.drawRectangle(canvas, options, this.pdfViewer.element.id, undefined, true, parentSvg);
    };
    /**
     * @private
     */


    Drawing.prototype.getSignBorder = function (type, options) {
      if (this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor = void 0;
        borderColor = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectionBorderColor === '' ? '#0000ff' : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor; // tslint:disable-next-line:max-line-length

        var thickness = void 0;
        thickness = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash = void 0;
        lineDash = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash.length > 2) {
          lineDash = [lineDash[0], lineDash[1]];
        }

        options.dashArray = lineDash.toString();
      } else {
        var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

        var borderColor = annotationSelector.selectionBorderColor === '' ? 'black' : annotationSelector.selectionBorderColor;
        options.stroke = borderColor; // tslint:disable-next-line:max-line-length

        options.strokeWidth = annotationSelector.selectionBorderThickness === 1 ? 1 : annotationSelector.selectionBorderThickness;
        var lineDash = annotationSelector.selectorLineDashArray.length === 0 ? [6, 3] : annotationSelector.selectorLineDashArray;

        if (lineDash.length > 2) {
          lineDash = [lineDash[0], lineDash[1]];
        }

        options.dashArray = lineDash.toString();
      }
    };
    /**
     * @private
     */


    Drawing.prototype.getBorderSelector = function (type, options) {
      var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

      var borderColor = annotationSelector.selectionBorderColor === '' ? 'black' : annotationSelector.selectionBorderColor;
      options.stroke = borderColor; // tslint:disable-next-line:max-line-length

      options.strokeWidth = annotationSelector.selectionBorderThickness === 1 ? 1 : annotationSelector.selectionBorderThickness;
      var lineDash = annotationSelector.selectorLineDashArray.length === 0 ? [6, 3] : annotationSelector.selectorLineDashArray;

      if (lineDash.length > 2) {
        lineDash = [lineDash[0], lineDash[1]];
      }

      options.dashArray = lineDash.toString();

      if (type === 'Rectangle' && this.pdfViewer.rectangleSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_1 = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectionBorderColor === '' ? 'black' : this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_1; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_1 = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.rectangleSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_1.length > 2) {
          lineDash_1 = [lineDash_1[0], lineDash_1[1]];
        }

        options.dashArray = lineDash_1.toString();
      } else if (type === 'Ellipse' && this.pdfViewer.circleSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_2 = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.circleSettings.annotationSelectorSettings.selectionBorderColor === '' ? 'black' : this.pdfViewer.circleSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_2; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.circleSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_2 = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.circleSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.circleSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_2.length > 2) {
          lineDash_2 = [lineDash_2[0], lineDash_2[1]];
        }

        options.dashArray = lineDash_2.toString();
      } else if (type === 'Radius' && this.pdfViewer.radiusSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_3 = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.radiusSettings.annotationSelectorSettings.selectionBorderColor === '' ? 'black' : this.pdfViewer.radiusSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_3; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.radiusSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_3 = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.radiusSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.radiusSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_3.length > 2) {
          lineDash_3 = [lineDash_3[0], lineDash_3[1]];
        }

        options.dashArray = lineDash_3.toString();
      } else if (type === 'FreeText' && this.pdfViewer.freeTextSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_4 = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectionBorderColor === '' ? 'black' : this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_4; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_4 = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.freeTextSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_4.length > 2) {
          lineDash_4 = [lineDash_4[0], lineDash_4[1]];
        }

        options.dashArray = lineDash_4.toString();
      } else if (type === 'StickyNotes' && this.pdfViewer.stickyNotesSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_5 = sf.base.isNullOrUndefined(this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectionBorderColor === '' ? 'black' : this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_5; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_5 = sf.base.isNullOrUndefined(this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [6, 3] : this.pdfViewer.stickyNotesSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_5.length > 2) {
          lineDash_5 = [lineDash_5[0], lineDash_5[1]];
        }

        options.dashArray = lineDash_5.toString();
      } else if (type === 'Stamp' && this.pdfViewer.stampSettings.annotationSelectorSettings) {
        // tslint:disable-next-line:max-line-length
        var borderColor_6 = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.selectionBorderColor) || this.pdfViewer.stampSettings.annotationSelectorSettings.selectionBorderColor === '' ? '#0000ff' : this.pdfViewer.stampSettings.annotationSelectorSettings.selectionBorderColor;
        options.stroke = borderColor_6; // tslint:disable-next-line:max-line-length

        var thickness = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.selectionBorderThickness) ? 1 : this.pdfViewer.stampSettings.annotationSelectorSettings.selectionBorderThickness;
        options.strokeWidth = thickness; // tslint:disable-next-line:max-line-length

        var lineDash_6 = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.selectorLineDashArray) || this.pdfViewer.stampSettings.annotationSelectorSettings.selectorLineDashArray.length === 0 ? [4] : this.pdfViewer.stampSettings.annotationSelectorSettings.selectorLineDashArray;

        if (lineDash_6.length > 2) {
          lineDash_6 = [lineDash_6[0], lineDash_6[1]];
        }

        options.dashArray = lineDash_6.toString();
      }
    };
    /**
     * @private
     */


    Drawing.prototype.renderCircularHandle = function (id, selector, cx, cy, canvas, visible, enableSelector, t, connected, canMask, ariaLabel, count, className, currentSelector) {
      var wrapper = selector;
      var newPoint = {
        x: cx,
        y: cy
      };
      t = t || {
        scale: 1,
        tx: 0,
        ty: 0
      };

      if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
        var matrix = sf.drawings.identityMatrix();
        sf.drawings.rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);
        newPoint = sf.drawings.transformPointByMatrix(matrix, newPoint);
      }

      var options = getBaseShapeAttributes(wrapper);
      var shapeType;

      if (this.pdfViewer.selectedItems.annotations[0].measureType) {
        shapeType = this.pdfViewer.selectedItems.annotations[0].measureType;
      } else {
        shapeType = this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType;
      }

      this.getResizerColors(shapeType, options, currentSelector, t);
      this.getShapeSize(shapeType, options, currentSelector, t);
      options.strokeWidth = 1;

      if (count !== undefined) {
        options.id = 'segmentEnd_' + count;
      }

      options.centerX = (newPoint.x + t.tx) * t.scale;
      options.centerY = (newPoint.y + t.ty) * t.scale;
      options.angle = 0;
      options.id = id;
      options.visible = visible;
      options.class = className;
      options.opacity = 1;

      if (connected) {
        options.class += ' e-connected';
      }

      if (canMask) {
        options.visible = false;
      }

      options.x = newPoint.x * t.scale - options.width / 2;
      options.y = newPoint.y * t.scale - options.height / 2;
      var parentSvg = this.getParentSvg(selector, 'selector');

      if (this.getShape(shapeType, currentSelector) === 'Square') {
        // tslint:disable-next-line:max-line-length
        this.svgRenderer.drawRectangle(canvas, options, id, undefined, true, parentSvg);
      } else if (this.getShape(shapeType, currentSelector) === 'Circle') {
        // tslint:disable-next-line:max-line-length
        this.svgRenderer.drawCircle(canvas, options, 1);
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.getShapeSize = function (type, options, currentSelector, t) {
      if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
        // tslint:disable-next-line
        var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

        options.radius = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) / 2; // tslint:disable-next-line:max-line-length

        options.width = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

        options.height = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) * t.scale;
      } else {
        // tslint:disable-next-line
        var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

        options.radius = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) / 2; // tslint:disable-next-line:max-line-length

        options.width = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

        options.height = (sf.base.isNullOrUndefined(annotationSelector.resizerSize) || annotationSelector.resizerSize === 8 ? 8 : annotationSelector.resizerSize) * t.scale;

        if (type === 'Line' && this.pdfViewer.lineSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'LineWidthArrowHead' && this.pdfViewer.arrowSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Rectangle' && this.pdfViewer.rectangleSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Ellipse' && this.pdfViewer.circleSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Distance' && this.pdfViewer.distanceSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Polygon' && this.pdfViewer.polygonSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Radius' && this.pdfViewer.radiusSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Stamp' && this.pdfViewer.stampSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'FreeText' && this.pdfViewer.freeTextSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'HandWrittenSignature' && this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Perimeter' && this.pdfViewer.perimeterSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Area' && this.pdfViewer.areaSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerSize) * t.scale;
        } else if (type === 'Volume' && this.pdfViewer.volumeSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.radius = (sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) / 2; // tslint:disable-next-line:max-line-length

          options.width = (sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) * t.scale; // tslint:disable-next-line:max-line-length

          options.height = (sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize === 8 ? 8 : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerSize) * t.scale;
        }
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.getShape = function (type, currentSelector) {
      // tslint:disable-next-line
      var shapeType;
      {
        if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
          // tslint:disable-next-line
          var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

          shapeType = sf.base.isNullOrUndefined(annotationSelector.resizerShape) || annotationSelector.resizerShape === 'Square' ? 'Square' : annotationSelector.resizerShape;
        } else {
          // tslint:disable-next-line
          var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

          shapeType = sf.base.isNullOrUndefined(annotationSelector.resizerShape) || annotationSelector.resizerShape === 'Square' ? 'Square' : annotationSelector.resizerShape;

          if (type === 'Line' && this.pdfViewer.lineSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'LineWidthArrowHead' && this.pdfViewer.arrowSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Rectangle' && this.pdfViewer.rectangleSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Ellipse' && this.pdfViewer.circleSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Polygon' && this.pdfViewer.polygonSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Distance' && this.pdfViewer.distanceSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Radius' && this.pdfViewer.radiusSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Stamp' && this.pdfViewer.stampSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'FreeText' && this.pdfViewer.freeTextSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'HandWrittenSignature' && this.pdfViewer.handWrittenSignatureSettings && this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Perimeter' && this.pdfViewer.perimeterSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Area' && this.pdfViewer.areaSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerShape;
          } else if (type === 'Volume' && this.pdfViewer.volumeSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            shapeType = sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerShape) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerShape === 'Square' ? 'Square' : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerShape;
          }
        }

        return shapeType;
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.getResizerColors = function (type, options, currentSelector, t) {
      if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
        // tslint:disable-next-line
        var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

        options.stroke = sf.base.isNullOrUndefined(annotationSelector.resizerBorderColor) || annotationSelector.resizerBorderColor === 'black' ? 'black' : annotationSelector.resizerBorderColor; // tslint:disable-next-line:max-line-length

        options.fill = sf.base.isNullOrUndefined(annotationSelector.resizerFillColor) || annotationSelector.resizerFillColor === '#FF4081' ? '#FF4081' : annotationSelector.resizerFillColor;
      } else {
        // tslint:disable-next-line
        var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

        options.stroke = sf.base.isNullOrUndefined(annotationSelector.resizerBorderColor) || annotationSelector.resizerBorderColor === 'black' ? 'black' : annotationSelector.resizerBorderColor; // tslint:disable-next-line:max-line-length

        options.fill = sf.base.isNullOrUndefined(annotationSelector.resizerFillColor) || annotationSelector.resizerFillColor === '#FF4081' ? '#FF4081' : annotationSelector.resizerFillColor;

        if (type === 'Line' && this.pdfViewer.lineSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'LineWidthArrowHead' && this.pdfViewer.arrowSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Rectangle' && this.pdfViewer.rectangleSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Ellipse' && this.pdfViewer.circleSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Distance' && this.pdfViewer.distanceSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Polygon' && this.pdfViewer.polygonSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Radius' && this.pdfViewer.radiusSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Stamp' && this.pdfViewer.stampSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'FreeText' && this.pdfViewer.freeTextSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'HandWrittenSignature' && this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Perimeter' && this.pdfViewer.perimeterSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.perimeterSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Area' && this.pdfViewer.areaSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.areaSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.areaSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.areaSettings.annotationSelectorSettings.resizerFillColor;
        } else if (type === 'Volume' && this.pdfViewer.volumeSettings.annotationSelectorSettings) {
          // tslint:disable-next-line:max-line-length
          options.stroke = sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerBorderColor) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerBorderColor === 'black' ? 'black' : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerBorderColor; // tslint:disable-next-line:max-line-length

          options.fill = sf.base.isNullOrUndefined(this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerFillColor) || this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerFillColor === '#FF4081' ? '#FF4081' : this.pdfViewer.volumeSettings.annotationSelectorSettings.resizerFillColor;
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.renderRotateThumb = function (wrapper, canvas, transform, selectorConstraints, canMask) {
      var element = new sf.drawings.PathElement();
      var newPoint;
      var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;
      var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;
      var pivotX = left + wrapper.pivot.x * wrapper.actualSize.width;
      var pivotY = top;
      pivotX = (pivotX + transform.tx) * transform.scale;
      pivotY = (pivotY + transform.ty) * transform.scale;
      newPoint = {
        x: pivotX,
        y: pivotY - 25
      };

      if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
        var matrix = sf.drawings.identityMatrix();
        sf.drawings.rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, (transform.tx + wrapper.offsetX) * transform.scale, (transform.ty + wrapper.offsetY) * transform.scale);
        newPoint = sf.drawings.transformPointByMatrix(matrix, newPoint);
      }

      var options = getBaseShapeAttributes(wrapper);
      options.stroke = 'black';
      options.strokeWidth = 1;
      options.opacity = 1;
      options.fill = '#FF4081';
      options.centerX = newPoint.x;
      options.centerY = newPoint.y;
      options.radius = 4;
      options.angle = 0;
      options.visible = true;
      options.class = 'e-diagram-rotate-handle';
      options.id = 'rotateThumb'; // tslint:disable-next-line:max-line-length

      this.svgRenderer.drawCircle(canvas, options, sf.drawings.ThumbsConstraints.Rotate, {
        'aria-label': 'Thumb to rotate the selected object'
      });
    };
    /**
     * @private
     */


    Drawing.prototype.renderResizeHandle = function (element, canvas, constraints, currentZoom, canMask, enableNode, nodeConstraints, isStamp, isSticky, isPath, isFreeText, currentSelector) {
      var left = element.offsetX - element.actualSize.width * element.pivot.x;
      var top = element.offsetY - element.actualSize.height * element.pivot.y;
      var height = element.actualSize.height;
      var width = element.actualSize.width;
      var transform = {
        scale: currentZoom,
        tx: 0,
        ty: 0
      };

      if (isStamp) {
        this.renderPivotLine(element, canvas, transform);
        this.renderRotateThumb(element, canvas, transform);
      }

      if (isFreeText) {
        isStamp = true;
      }

      this.renderBorder(element, canvas, currentSelector, transform, enableNode, nodeConstraints, true, isSticky);
      var nodeWidth = element.actualSize.width * currentZoom;
      var nodeHeight = element.actualSize.height * currentZoom;
      var shapeType = this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType;
      var resizerLocation = this.getResizerLocation(shapeType, currentSelector);

      if (resizerLocation < 1 || resizerLocation > 3) {
        resizerLocation = 3;
      }

      var isNodeShape = false; // tslint:disable-next-line:max-line-length

      if (this.pdfViewer.selectedItems.annotations[0] && (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Ellipse' || this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Radius' || this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Rectangle')) {
        isNodeShape = true;
      }

      if (!nodeConstraints && !isSticky && !isPath) {
        if (isStamp || isNodeShape && nodeWidth >= 40 && nodeHeight >= 40 && (resizerLocation === 1 || resizerLocation === 3)) {
          //Hide corners when the size is less than 40
          this.renderCircularHandle('resizeNorthWest', element, left, top, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeNorthWest, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on top left side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-northwest', currentSelector);
          this.renderCircularHandle('resizeNorthEast', element, left + width, top, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeNorthEast, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on top right side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-northeast', currentSelector);
          this.renderCircularHandle('resizeSouthWest', element, left, top + height, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeSouthWest, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on bottom left side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-southwest', currentSelector);
          this.renderCircularHandle('resizeSouthEast', element, left + width, top + height, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeSouthEast, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on bottom right side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-southeast', currentSelector);
        } // tslint:disable-next-line:max-line-length


        if (!isStamp && !isNodeShape || isNodeShape && (resizerLocation === 2 || resizerLocation === 3 || !(nodeWidth >= 40 && nodeHeight >= 40) && resizerLocation === 1)) {
          this.renderCircularHandle('resizeNorth', element, left + width / 2, top, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeNorth, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on top side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-north', currentSelector);
          this.renderCircularHandle('resizeSouth', element, left + width / 2, top + height, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeSouth, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on bottom side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-south', currentSelector);
          this.renderCircularHandle('resizeWest', element, left, top + height / 2, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeWest, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on left side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-west', currentSelector);
          this.renderCircularHandle('resizeEast', element, left + width, top + height / 2, canvas, true, constraints & sf.drawings.ThumbsConstraints.ResizeEast, transform, undefined, canMask, {
            'aria-label': 'Thumb to resize the selected object on right side direction'
          }, undefined, 'e-pv-diagram-resize-handle e-east', currentSelector);
        }
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.getResizerLocation = function (type, currentSelector) {
      // tslint:disable-next-line
      var resizerLocation;
      {
        if (currentSelector && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(currentSelector) !== 'object' && currentSelector !== '') {
          // tslint:disable-next-line
          var annotationSelector = JSON.parse(currentSelector); // tslint:disable-next-line:max-line-length

          resizerLocation = sf.base.isNullOrUndefined(annotationSelector.resizerLocation) || annotationSelector.resizerLocation === 3 ? 3 : annotationSelector.resizerLocation;
        } else {
          // tslint:disable-next-line
          var annotationSelector = this.pdfViewer.annotationSelectorSettings; // tslint:disable-next-line:max-line-length

          resizerLocation = sf.base.isNullOrUndefined(annotationSelector.resizerLocation) || annotationSelector.resizerLocation === 3 ? 3 : annotationSelector.resizerLocation;

          if (type === 'Line' && this.pdfViewer.lineSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.lineSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.lineSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.lineSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'LineWidthArrowHead' && this.pdfViewer.arrowSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.arrowSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Rectangle' && this.pdfViewer.rectangleSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.rectangleSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Ellipse' && this.pdfViewer.circleSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.circleSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.circleSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.circleSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Polygon' && this.pdfViewer.polygonSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.polygonSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Distance') {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.distanceSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Radius' && this.pdfViewer.radiusSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.radiusSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'Stamp' && this.pdfViewer.stampSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.stampSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.stampSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.stampSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'FreeText' && this.pdfViewer.freeTextSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.freeTextSettings.annotationSelectorSettings.resizerLocation;
          } else if (type === 'HandWrittenSignature' && this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings) {
            // tslint:disable-next-line:max-line-length
            resizerLocation = sf.base.isNullOrUndefined(this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerLocation) || this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerLocation === 3 ? 3 : this.pdfViewer.handWrittenSignatureSettings.annotationSelectorSettings.resizerLocation;
          }
        }

        return resizerLocation;
      }
    };
    /**
     * @private
     */


    Drawing.prototype.renderPivotLine = function (element, canvas, transform, selectorConstraints, canMask) {
      var wrapper = element;
      var dashArray = '2,3';
      var visible = true;

      if (canMask) {
        visible = false;
      }

      var options = getBaseShapeAttributes(wrapper, transform);
      options.fill = 'None';
      options.stroke = 'black';
      options.strokeWidth = 1;
      options.dashArray = dashArray;
      options.visible = visible;
      var scale = transform.scale;
      options.x *= scale;
      options.y *= scale;
      options.width *= scale;
      options.height *= scale;
      options.id = 'pivotLine';
      options.class = 'e-diagram-pivot-line';
      var startPoint = {
        x: wrapper.actualSize.width * wrapper.pivot.x * scale,
        y: -20
      };
      var endPoint = {
        x: wrapper.actualSize.width * wrapper.pivot.x * scale,
        y: 0
      };
      options.startPoint = startPoint;
      options.endPoint = endPoint;
      this.svgRenderer.drawLine(canvas, options);
    };
    /**
     * @private
     */


    Drawing.prototype.renderEndPointHandle = function (selector, canvas, constraints, transform, connectedSource, connectedTarget, isSegmentEditing, currentSelector) {
      transform = transform || {
        tx: 0,
        ty: 0,
        scale: 1
      };
      var sourcePoint = selector.sourcePoint;
      var targetPoint = selector.targetPoint;
      var wrapper = selector.wrapper;
      var i;

      for (i = 0; i < selector.vertexPoints.length; i++) {
        var segment = selector.vertexPoints[i];
        this.renderCircularHandle('segementThumb_' + (i + 1), wrapper, segment.x, segment.y, canvas, true, constraints & sf.drawings.ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i, null, currentSelector);
      }

      var leaderCount = 0;

      if (selector.shapeAnnotationType === 'Distance') {
        for (i = 0; i < selector.wrapper.children.length; i++) {
          var segment = selector.wrapper.children[i];
          var newPoint1 = void 0;
          var angle = sf.drawings.Point.findAngle(selector.sourcePoint, selector.targetPoint);

          if (segment.id.indexOf('leader') > -1) {
            var center = selector.wrapper.children[0].bounds.center;

            if (leaderCount === 0) {
              newPoint1 = {
                x: selector.sourcePoint.x,
                y: selector.sourcePoint.y - selector.leaderHeight
              };
              center = sourcePoint;
            } else {
              newPoint1 = {
                x: selector.targetPoint.x,
                y: selector.targetPoint.y - selector.leaderHeight
              };
              center = targetPoint;
            }

            var matrix = sf.drawings.identityMatrix();
            sf.drawings.rotateMatrix(matrix, angle, center.x, center.y);
            var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, {
              x: newPoint1.x,
              y: newPoint1.y
            }); // tslint:disable-next-line:max-line-length

            this.renderCircularHandle('leaderThumb_' + (i + 1), wrapper, rotatedPoint.x, rotatedPoint.y, canvas, true, constraints & sf.drawings.ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i, null, currentSelector);
            leaderCount++;
          }
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.initSelectorWrapper = function () {
      var selectorModel = this.pdfViewer.selectedItems;
      selectorModel.init(this);
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.select = function (objArray, currentSelector, multipleSelection, preventUpdate) {
      var selectorModel = this.pdfViewer.selectedItems;

      for (var i = 0; i < objArray.length; i++) {
        // tslint:disable-next-line
        var obj = this.pdfViewer.nameTable[objArray[i]];

        if (obj) {
          if (!(obj instanceof Selector) && obj.wrapper.visible) {
            // tslint:disable-next-line
            var annotationSettings = void 0;

            if (obj.annotationSettings) {
              annotationSettings = obj.annotationSettings;
              annotationSettings.isLock = JSON.parse(annotationSettings.isLock);
            } else {
              annotationSettings = this.pdfViewer.annotationModule.findAnnotationSettings(obj, true);
              obj.annotationSettings = annotationSettings;
            }

            if (!annotationSettings.isLock) {
              selectorModel.annotations.push(obj);
              this.initSelectorWrapper();
              selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;
              selectorModel.wrapper.children.push(obj.wrapper);

              if (!preventUpdate) {
                this.renderSelector(obj.pageIndex, currentSelector, obj, true);
              }
            }
          }
        }
      }
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.dragSelectedObjects = function (tx, ty, pageIndex, currentSelector, helper) {
      var obj = this.pdfViewer.selectedItems;
      this.drag(obj, tx, ty, currentSelector, helper);
      return true;
    };
    /**
     * @private
     */
    // tslint:disable-next-line


    Drawing.prototype.drag = function (obj, tx, ty, currentSelector, helper) {
      if (obj instanceof Selector) {
        if (obj.annotations.length) {
          for (var _i = 0, _a = obj.annotations; _i < _a.length; _i++) {
            var node = _a[_i];
            this.drag(node, tx, ty, currentSelector, helper);
            this.renderSelector(node.pageIndex, currentSelector, helper);
          }
        }
      } else {
        this.dragAnnotation(obj, tx, ty);
      }
    };
    /**
     * @private
     */


    Drawing.prototype.dragAnnotation = function (obj, tx, ty) {
      var oldValues = {
        x: obj.wrapper.offsetX,
        y: obj.wrapper.offsetY
      };
      obj.wrapper.offsetX += tx;
      obj.wrapper.offsetY += ty;

      if (isLineShapes(obj) || obj.shapeAnnotationType === 'Polygon') {
        if (obj.wrapper.children.length) {
          var nodes = obj.wrapper.children;

          for (var i = 0; i < nodes.length; i++) {
            nodes[i].offsetX += tx;
            nodes[i].offsetY += ty;
          }
        }

        this.dragControlPoint(obj, tx, ty, true);
      }

      this.nodePropertyChange(obj, {
        bounds: {
          x: obj.wrapper.offsetX,
          y: obj.wrapper.offsetY
        }
      });
      obj.wrapper.measureChildren = false; // tslint:disable-next-line

      var canvas = document.getElementById(this.pdfViewer.element.id + '_annotationCanvas_' + obj.pageIndex); // tslint:disable-next-line

      this.pdfViewer.renderDrawing(canvas, obj.pageIndex);
    };
    /**
     * @private
     */


    Drawing.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {
      // tslint:disable-next-line
      var connector = this.pdfViewer.nameTable[obj.id];

      for (var i = 0; i < connector.vertexPoints.length; i++) {
        connector.vertexPoints[i].x += tx;
        connector.vertexPoints[i].y += ty;
      }

      if (!preventUpdate) {
        this.updateEndPoint(connector);
      }

      return true;
    };
    /**
     * @private
     */


    Drawing.prototype.updateEndPoint = function (connector) {
      this.nodePropertyChange(connector, {
        vertexPoints: connector.vertexPoints
      });
      this.renderSelector(connector.pageIndex);
    };
    /**
     * @private
     */

    /* tslint:disable */


    Drawing.prototype.nodePropertyChange = function (actualObject, node) {
      var existingBounds = actualObject.wrapper.outerBounds;
      var existingInnerBounds = actualObject.wrapper.bounds;
      var i;

      if (node.bounds) {
        if (node.bounds.width !== undefined) {
          actualObject.bounds.width = actualObject.wrapper.width = node.bounds.width;
        }

        if (node.bounds.height !== undefined) {
          actualObject.bounds.height = actualObject.wrapper.height = node.bounds.height;
        }

        if (node.bounds.x !== undefined) {
          actualObject.bounds.x = node.bounds.x - actualObject.bounds.width * 0.5;
          actualObject.wrapper.offsetX = node.bounds.x;
        }

        if (node.bounds.y !== undefined) {
          actualObject.bounds.y = node.bounds.y - actualObject.bounds.height * 0.5;
          actualObject.wrapper.offsetY = node.bounds.y;
        }

        if (node.leaderHeight !== undefined) {
          actualObject.leaderHeight = node.leaderHeight;
          this.updateConnector(actualObject, actualObject.vertexPoints);
        }

        if (actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;

          for (var i_1 = 0; i_1 < children.length; i_1++) {
            if (children[i_1].id) {
              var names = children[i_1].id.split('_');

              if (names.length && (names.indexOf('perimeter') > -1 || names.indexOf('radius') > -1)) {
                this.setNodePosition(children[i_1], actualObject);
              } else if (names.length && names.indexOf('srcDec') > -1) {
                children[i_1].offsetX = actualObject.vertexPoints[0].x;
                children[i_1].offsetY = actualObject.vertexPoints[0].y;
              } else if (names.length && names.indexOf('tarDec') > -1) {
                children[i_1].offsetX = actualObject.vertexPoints[actualObject.vertexPoints.length - 1].x;
                children[i_1].offsetY = actualObject.vertexPoints[actualObject.vertexPoints.length - 1].y;
              } else if (names.length && names.indexOf('stamp') > -1) {
                var ratio = 0;
                var heightRatio = 2;

                if (actualObject.wrapper.width != undefined && actualObject.wrapper.height != undefined) {
                  ratio = 20;
                  heightRatio = 2.9;
                }

                if (actualObject.isDynamicStamp) {
                  children[i_1].width = actualObject.bounds.width - ratio;
                  children[i_1].height = actualObject.bounds.height / 2 - ratio;
                  var element = children[1];
                  var annotationSettings = this.pdfViewer.stampSettings ? this.pdfViewer.stampSettings : this.pdfViewer.annotationSettings;

                  if (annotationSettings && (annotationSettings.maxHeight || annotationSettings.maxWidth) && actualObject.bounds.height > 60) {
                    if (actualObject.bounds.height * 3 < actualObject.bounds.width) {
                      element.style.fontSize = actualObject.bounds.height / 2 / heightRatio;
                    } else {
                      if (actualObject.bounds.height > actualObject.bounds.width) {
                        element.style.fontSize = actualObject.bounds.width / 8 / heightRatio;
                      } else if (actualObject.bounds.height * 2 < actualObject.bounds.width) {
                        element.style.fontSize = actualObject.bounds.height / 4 / heightRatio;
                      } else {
                        element.style.fontSize = actualObject.bounds.height / 6 / heightRatio;
                      }
                    }
                  } else {
                    element.style.fontSize = actualObject.bounds.height / 2 / heightRatio;
                  }

                  if (ratio != 0) {
                    element.margin.bottom = -(children[i_1].height / 2);
                  }
                } else {
                  children[i_1].width = actualObject.bounds.width - ratio;
                  children[i_1].height = actualObject.bounds.height - ratio;
                }

                children[i_1].offsetX = actualObject.wrapper.offsetX;
                children[i_1].offsetY = actualObject.wrapper.offsetX;
                children[i_1].isDirt = true;
              }
            }
          }
        }
      }

      if (node.sourceDecoraterShapes !== undefined) {
        actualObject.sourceDecoraterShapes = node.sourceDecoraterShapes;
        this.updateConnector(actualObject, actualObject.vertexPoints);
      }

      if (node.taregetDecoraterShapes !== undefined) {
        actualObject.taregetDecoraterShapes = node.taregetDecoraterShapes;
        this.updateConnector(actualObject, actualObject.vertexPoints);
      }

      if (node.fillColor !== undefined) {
        actualObject.fillColor = node.fillColor;
        actualObject.wrapper.children[0].style.fill = node.fillColor;

        if ((actualObject.enableShapeLabel || actualObject.measureType) && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_2 = 0; i_2 < children.length; i_2++) {
            if (children[i_2].textNodes) {
              if (actualObject.enableShapeLabel) {
                actualObject.labelFillColor = node.fillColor;
                children[i_2].style.fill = node.fillColor;
              }

              if (actualObject.measureType) {
                children[i_2].style.fill = node.fillColor;
              }
            }
          }
        }
      }

      if (actualObject.enableShapeLabel && node.labelFillColor !== undefined) {
        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_3 = 0; i_3 < children.length; i_3++) {
            if (children[i_3].textNodes) {
              children[i_3].style.fill = node.labelFillColor;
            }
          }
        }
      }

      if (node.opacity !== undefined) {
        if (actualObject.shapeAnnotationType == "Stamp" || actualObject.shapeAnnotationType === "FreeText") {
          actualObject.wrapper.children[1].style.opacity = node.opacity;

          if (actualObject.wrapper.children[2]) {
            actualObject.wrapper.children[2].style.opacity = node.opacity;
          }
        } else {
          actualObject.opacity = node.opacity;
        }

        actualObject.wrapper.children[0].style.opacity = node.opacity;

        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_4 = 0; i_4 < children.length; i_4++) {
            if (children[i_4].textNodes) {
              children[i_4].style.opacity = node.labelOpacity;
            }
          }
        }
      }

      if (actualObject.enableShapeLabel && node.labelOpacity !== undefined) {
        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_5 = 0; i_5 < children.length; i_5++) {
            if (children[i_5].textNodes) {
              children[i_5].style.opacity = node.labelOpacity;
            }
          }
        }
      }

      if (node.rotateAngle !== undefined) {
        actualObject.rotateAngle = node.rotateAngle;
        actualObject.wrapper.rotateAngle = node.rotateAngle;
      }

      if (node.strokeColor !== undefined) {
        actualObject.strokeColor = node.strokeColor;
        actualObject.wrapper.children[0].style.strokeColor = node.strokeColor;
      }

      if (node.fontColor !== undefined) {
        actualObject.fontColor = node.fontColor;

        if (actualObject.shapeAnnotationType === 'FreeText' && actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;
          children[1].style.color = node.fontColor;

          if (actualObject.textAlign === 'Justify') {
            children[1].horizontalAlignment = 'Center';
          } else {
            children[1].horizontalAlignment = 'Auto';
          }
        }

        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_6 = 0; i_6 < children.length; i_6++) {
            if (children[i_6].textNodes) {
              children[i_6].style.color = node.fontColor;
            }
          }
        }
      }

      if (node.fontFamily !== undefined) {
        actualObject.fontFamily = node.fontFamily;

        if (actualObject.shapeAnnotationType === 'FreeText' && actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;
          children[1].style.fontFamily = node.fontFamily;
        }

        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_7 = 0; i_7 < children.length; i_7++) {
            if (children[i_7].textNodes) {
              children[i_7].style.fontFamily = node.fontFamily;
            }
          }
        }
      }

      if (node.fontSize !== undefined) {
        actualObject.fontSize = node.fontSize;

        if (actualObject.shapeAnnotationType === 'FreeText' && actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;
          children[1].style.fontSize = node.fontSize;
        }

        if (actualObject.enableShapeLabel && actualObject.wrapper && actualObject.wrapper.children) {
          var children = actualObject.wrapper.children;

          for (var i_8 = 0; i_8 < children.length; i_8++) {
            if (children[i_8].textNodes) {
              children[i_8].style.fontSize = node.fontSize;
            }
          }
        }
      }

      if (node.font !== undefined) {
        if (actualObject.shapeAnnotationType === 'FreeText' && actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;

          if (node.font.isBold !== undefined) {
            children[1].style.bold = node.font.isBold;
            actualObject.font.isBold = node.font.isBold;
          }

          if (node.font.isItalic !== undefined) {
            children[1].style.italic = node.font.isItalic;
            actualObject.font.isItalic = node.font.isItalic;
          }

          if (node.font.isUnderline !== undefined) {
            actualObject.font.isStrikeout = false;

            if (node.font.isUnderline === true) {
              children[1].style.textDecoration = 'Underline';
            } else {
              children[1].style.textDecoration = 'None';
            }

            actualObject.font.isUnderline = node.font.isUnderline;
          }

          if (node.font.isStrikeout !== undefined) {
            actualObject.font.isUnderline = false;

            if (node.font.isStrikeout === true) {
              children[1].style.textDecoration = 'LineThrough';
            } else {
              children[1].style.textDecoration = 'None';
            }

            actualObject.font.isStrikeout = node.font.isStrikeout;
          }
        }
      }

      if (node.textAlign !== undefined) {
        actualObject.textAlign = node.textAlign;

        if (actualObject.shapeAnnotationType === 'FreeText' && actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;
          children[1].style.textAlign = node.textAlign;

          if (children[1].childNodes.length === 1) {
            if (actualObject.textAlign === 'Justify') {
              children[1].horizontalAlignment = 'Left';
              children[1].setOffsetWithRespectToBounds(0, 0, null);
            } else if (actualObject.textAlign === 'Right') {
              children[1].horizontalAlignment = 'Right';
              children[1].setOffsetWithRespectToBounds(0.97, 0, null);
            } else if (actualObject.textAlign === 'Left') {
              children[1].horizontalAlignment = 'Left';
              children[1].setOffsetWithRespectToBounds(0, 0, null);
            } else if (actualObject.textAlign === 'Center') {
              children[1].horizontalAlignment = 'Center';
              children[1].setOffsetWithRespectToBounds(0.46, 0, null);
            }
          } else if (children[1].childNodes.length > 1 && actualObject.textAlign === 'Justify') {
            children[1].horizontalAlignment = 'Center';
          } else {
            children[1].horizontalAlignment = 'Auto';
          }
        }
      }

      if (node.thickness !== undefined) {
        actualObject.thickness = node.thickness;
        actualObject.wrapper.children[0].style.strokeWidth = node.thickness;
      }

      if (node.borderDashArray !== undefined) {
        actualObject.borderDashArray = node.borderDashArray;
        actualObject.wrapper.children[0].style.strokeDashArray = node.borderDashArray;
      }

      if (node.borderStyle !== undefined) {
        actualObject.borderStyle = node.borderStyle;
      }

      if (node.vertexPoints !== undefined) {
        actualObject.vertexPoints = node.vertexPoints;
        this.pdfViewer.nameTable[actualObject.id].vertexPoints = node.vertexPoints;
        this.updateConnector(actualObject, node.vertexPoints);
      }

      if (node.leaderHeight !== undefined && actualObject.shapeAnnotationType !== 'Polygon') {
        actualObject.leaderHeight = node.leaderHeight;
        this.updateConnector(actualObject, actualObject.vertexPoints);
      }

      if (node.notes !== undefined) {
        actualObject.notes = node.notes;
      }

      if (node.annotName !== undefined) {
        actualObject.annotName = node.annotName;
      }

      if (actualObject.shapeAnnotationType === 'Distance') {
        for (i = 0; i < actualObject.wrapper.children.length; i++) {
          var segment = actualObject.wrapper.children[i];
          var points = getConnectorPoints(actualObject);

          if (segment.id.indexOf('leader1') > -1) {
            this.setLineDistance(actualObject, points, segment, false);
          }

          if (segment.id.indexOf('leader2') > -1) {
            this.setLineDistance(actualObject, points, segment, true);
          }
        }

        this.updateConnector(actualObject, actualObject.vertexPoints);
      }

      if (actualObject.shapeAnnotationType === 'Polygon' && node.vertexPoints) {
        actualObject.data = getPolygonPath(actualObject.vertexPoints);
        var path = actualObject.wrapper.children[0];
        path.data = actualObject.data;
        path.canMeasurePath = true;
      }

      if (isLineShapes(actualObject)) {
        for (var i_9 = 0; i_9 < actualObject.wrapper.children.length; i_9++) {
          var childElement = actualObject.wrapper.children[i_9];

          if (!childElement.textNodes) {
            setElementStype(actualObject, actualObject.wrapper.children[i_9]);
          }

          if (actualObject.enableShapeLabel === true) {
            if (actualObject.wrapper.children[i_9] instanceof sf.drawings.TextElement) {
              actualObject.wrapper.children[i_9].style.fill = actualObject.labelFillColor;
            }

            if (actualObject.wrapper.children[i_9] instanceof sf.drawings.PathElement && actualObject.measureType === 'Perimeter') {
              actualObject.wrapper.children[i_9].style.fill = 'transparent';
            }
          } else {
            if (actualObject.wrapper.children[i_9] instanceof sf.drawings.PathElement && actualObject.measureType === 'Perimeter' || actualObject.wrapper.children[i_9] instanceof sf.drawings.TextElement) {
              actualObject.wrapper.children[i_9].style.fill = 'transparent';
            }
          }
        }
      }

      if (actualObject && (actualObject.shapeAnnotationType === "FreeText" || actualObject.enableShapeLabel === true)) {
        if (actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;

          for (var i_10 = 0; i_10 < children.length; i_10++) {
            if (children[i_10].textNodes) {
              if (actualObject.shapeAnnotationType === "FreeText") {
                if (node.dynamicText !== undefined) {
                  children[i_10].content = node.dynamicText;
                  actualObject.dynamicText = node.dynamicText;
                } else {
                  children[i_10].content = actualObject.dynamicText;
                }

                children[i_10].width = actualObject.bounds.width - 8;
              } else if (actualObject.enableShapeLabel === true && actualObject.measureType) {
                if (node.labelContent) {
                  children[i_10].content = node.labelContent;
                  actualObject.labelContent = node.labelContent;
                } else {
                  children[i_10].content = actualObject.labelContent;
                }

                actualObject.notes = children[i_10].content;
              } else if (actualObject.enableShapeLabel === true) {
                if (node.labelContent) {
                  children[i_10].content = node.labelContent;
                  actualObject.labelContent = node.labelContent;
                } else {
                  children[i_10].content = actualObject.labelContent;
                }

                actualObject.notes = children[i_10].content;
              }

              children[i_10].isDirt = true;
            }
            /** set text node width less than the parent */

          }
        }
      }

      actualObject.wrapper.measure(new sf.drawings.Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height));
      actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);

      if (actualObject && actualObject.shapeAnnotationType === "FreeText" && actualObject.subject === "Text Box") {
        if (actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;

          if (children[1].childNodes.length > 1 && actualObject.textAlign === 'Justify') {
            children[1].horizontalAlignment = 'Center';
          } else if (children[1].childNodes.length === 1) {
            if (actualObject.textAlign === 'Justify') {
              children[1].horizontalAlignment = 'Left';
              children[1].setOffsetWithRespectToBounds(0, 0, null);
            } else if (actualObject.textAlign === 'Right') {
              children[1].horizontalAlignment = 'Right';
              children[1].setOffsetWithRespectToBounds(0.97, 0, null);
            } else if (actualObject.textAlign === 'Left') {
              children[1].horizontalAlignment = 'Left';
              children[1].setOffsetWithRespectToBounds(0, 0, null);
            } else if (actualObject.textAlign === 'Center') {
              children[1].horizontalAlignment = 'Center';
              children[1].setOffsetWithRespectToBounds(0.46, 0, null);
            }
          }

          for (var i_11 = 0; i_11 < children.length; i_11++) {
            if (children[i_11].textNodes && children[i_11].textNodes.length > 0) {
              children[i_11].isDirt = true;
              var childNodeHeight = children[i_11].textNodes.length * children[i_11].textNodes[0].dy;
              var heightDiff = actualObject.bounds.height - childNodeHeight;

              if (heightDiff > 0 && heightDiff < children[i_11].textNodes[0].dy) {
                childNodeHeight = childNodeHeight + children[i_11].textNodes[0].dy;
              }

              if (childNodeHeight > actualObject.bounds.height) {
                var contString = '';

                for (var index = 0; index < children[i_11].textNodes.length; index++) {
                  var childHeight = children[i_11].textNodes[0].dy * (index + 1);
                  childHeight = childHeight;

                  if (childHeight > actualObject.bounds.height) {
                    break;
                  }

                  contString = contString + children[i_11].textNodes[index].text;
                }

                children[i_11].content = contString;
              }
            }
            /** set text node width less than the parent */


            children[i_11].width = actualObject.bounds.width - 8;
          }
        }

        actualObject.wrapper.measure(new sf.drawings.Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height));
        actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
      }

      this.pdfViewer.renderDrawing(undefined, actualObject.pageIndex);

      if (actualObject && actualObject.shapeAnnotationType === "FreeText") {
        if (actualObject.wrapper && actualObject.wrapper.children && actualObject.wrapper.children.length) {
          var children = actualObject.wrapper.children;

          if (children[1].childNodes.length == 1 && actualObject.textAlign === 'Justify') {
            children[1].horizontalAlignment = 'Left';
            children[1].setOffsetWithRespectToBounds(0.5, 0, null);
          } else if (children[1].childNodes.length > 1 && actualObject.textAlign === 'Justify') {
            children[1].horizontalAlignment = 'Center';
            children[1].setOffsetWithRespectToBounds(0, 0, null);
          }
        }
      }
    };
    /* tslint:disable */


    Drawing.prototype.setLineDistance = function (actualObject, points, segment, leader) {
      var node1;

      if (leader) {
        node1 = initLeader(actualObject, points[1], points[0], leader);
      } else {
        node1 = initLeader(actualObject, points[0], points[1], leader);
      }

      segment.data = node1.data;
      segment.offsetX = node1.offsetX;
      segment.offsetY = node1.offsetY;
      segment.rotateAngle = node1.rotateAngle;
      segment.width = node1.width;
      segment.height = node1.height;
      segment.pivot = node1.pivot;
      segment.canMeasurePath = true;
      segment.isDirt = true;
    };
    /**
     * @private
     */


    Drawing.prototype.scaleSelectedItems = function (sx, sy, pivot) {
      var obj = this.pdfViewer.selectedItems;
      return this.scale(obj, sx, sy, pivot);
    };
    /**
     * @private
     */


    Drawing.prototype.scale = function (obj, sx, sy, pivot) {
      var checkBoundaryConstraints = true;

      if (obj instanceof Selector) {
        if (obj.annotations && obj.annotations.length) {
          for (var _i = 0, _a = obj.annotations; _i < _a.length; _i++) {
            var node = _a[_i];
            checkBoundaryConstraints = this.scaleAnnotation(node, sx, sy, pivot, obj);
          }
        }
      } else {
        checkBoundaryConstraints = this.scaleAnnotation(obj, sx, sy, pivot, undefined);
      }

      return checkBoundaryConstraints;
    };
    /**
     * @private
     */


    Drawing.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject) {
      sw = sw < 0 ? 1 : sw;
      sh = sh < 0 ? 1 : sh;

      if (sw !== 1 || sh !== 1) {
        var width = void 0;
        var height = void 0;

        if (!isLineShapes(obj)) {
          var node = obj;
          var isResize = void 0;
          var bound = void 0;
          width = node.wrapper.actualSize.width * sw;
          height = node.wrapper.actualSize.height * sh;

          if (isResize) {
            width = Math.max(width, bound.right - node.wrapper.bounds.x);
            height = Math.max(height, bound.bottom - node.wrapper.bounds.y);
          }

          sw = width / node.wrapper.actualSize.width;
          sh = height / node.wrapper.actualSize.height;
        }

        var matrix = sf.drawings.identityMatrix();
        var refWrapper = void 0;

        if (!refObject) {
          refObject = obj;
        }

        refWrapper = refObject.wrapper;
        sf.drawings.rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);
        sf.drawings.scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);
        sf.drawings.rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);

        if (!isLineShapes(obj)) {
          var node = obj;
          var left = void 0;
          var top_1;
          var newPosition = sf.drawings.transformPointByMatrix(matrix, {
            x: node.wrapper.offsetX,
            y: node.wrapper.offsetY
          });
          var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width;
          var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height;

          if (width > 0) {
            node.wrapper.width = width;
            node.wrapper.offsetX = newPosition.x;
          }

          if (height > 0) {
            node.wrapper.height = height;
            node.wrapper.offsetY = newPosition.y;
          }

          left = node.wrapper.offsetX - node.wrapper.actualSize.width; // * node.pivot.x;

          top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height; // * node.pivot.y;

          this.nodePropertyChange(obj, {
            bounds: {
              width: node.wrapper.width,
              height: node.wrapper.height,
              x: node.wrapper.offsetX,
              y: node.wrapper.offsetY
            }
          });
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.scaleAnnotation = function (obj, sw, sh, pivot, refObject) {
      var node = this.pdfViewer.nameTable[obj.id];
      var element = node.wrapper;

      if (!refObject) {
        refObject = obj;
      }

      var refWrapper = refObject.wrapper;
      var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;
      var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;
      var refPoint = this.getShapePoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);

      if (element.actualSize.width !== undefined && element.actualSize.height !== undefined) {
        this.scaleObject(sw, sh, refPoint, node, element, refObject);
        var bounds = this.getShapeBounds(obj.wrapper);
      }

      var constraints = this.checkBoundaryConstraints(undefined, undefined, obj.pageIndex, obj.wrapper.bounds);

      if (!constraints) {
        this.scaleObject(1 / sw, 1 / sh, refPoint, node, element, refObject);
      }

      return constraints;
    };
    /**
     * @private
     */


    Drawing.prototype.checkBoundaryConstraints = function (tx, ty, pageIndex, nodeBounds, isStamp) {
      var selectorBounds = !nodeBounds ? this.pdfViewer.selectedItems.wrapper.bounds : undefined;
      var bounds = nodeBounds;
      var canvas = document.getElementById(this.pdfViewer.element.id + '_annotationCanvas_' + pageIndex);
      var heightDifference = 10;

      if (canvas) {
        var width = canvas.clientWidth / this.pdfViewer.viewerBase.getZoomFactor();
        var height = canvas.clientHeight / this.pdfViewer.viewerBase.getZoomFactor();
        var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);
        var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);
        var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);
        var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);

        if (isStamp) {
          heightDifference = 50;

          if (this.pdfViewer.viewerBase.eventArgs && this.pdfViewer.viewerBase.eventArgs.source) {
            if (this.RestrictStamp(this.pdfViewer.viewerBase.eventArgs.source)) {
              return false;
            }
          }
        }

        if (right <= width - 10 && left >= 10 && bottom <= height - 10 && top_2 >= heightDifference) {
          return true;
        }
      }

      return false;
    };

    Drawing.prototype.RestrictStamp = function (source) {
      // tslint:disable-next-line:max-line-length
      if (source && source.pageIndex !== undefined && this.pdfViewer.viewerBase.activeElements && source.pageIndex !== this.pdfViewer.viewerBase.activeElements.activePageID) {
        return true;
      }

      return false;
    };
    /**
     * @private
     */


    Drawing.prototype.getShapeBounds = function (shapeElement) {
      var shapeBounds = new sf.drawings.Rect();
      var shapeCorners;
      shapeCorners = sf.drawings.cornersPointsBeforeRotation(shapeElement);
      var shapeMiddleLeft = shapeCorners.middleLeft;
      var shapeTopCenter = shapeCorners.topCenter;
      var shapeBottomCenter = shapeCorners.bottomCenter;
      var shapeMiddleRight = shapeCorners.middleRight;
      var shapeTopLeft = shapeCorners.topLeft;
      var shapeTopRight = shapeCorners.topRight;
      var shapeBottomLeft = shapeCorners.bottomLeft;
      var shapeBottomRight = shapeCorners.bottomRight;
      shapeElement.corners = {
        topLeft: shapeTopLeft,
        topCenter: shapeTopCenter,
        topRight: shapeTopRight,
        middleLeft: shapeMiddleLeft,
        middleRight: shapeMiddleRight,
        bottomLeft: shapeBottomLeft,
        bottomCenter: shapeBottomCenter,
        bottomRight: shapeBottomRight
      };

      if (shapeElement.rotateAngle !== 0 || shapeElement.parentTransform !== 0) {
        var matrix = sf.drawings.identityMatrix();
        sf.drawings.rotateMatrix(matrix, shapeElement.rotateAngle + shapeElement.parentTransform, shapeElement.offsetX, shapeElement.offsetY);
        shapeElement.corners.topLeft = shapeTopLeft = sf.drawings.transformPointByMatrix(matrix, shapeTopLeft);
        shapeElement.corners.topCenter = shapeTopCenter = sf.drawings.transformPointByMatrix(matrix, shapeTopCenter);
        shapeElement.corners.topRight = shapeTopRight = sf.drawings.transformPointByMatrix(matrix, shapeTopRight);
        shapeElement.corners.middleLeft = shapeMiddleLeft = sf.drawings.transformPointByMatrix(matrix, shapeMiddleLeft);
        shapeElement.corners.middleRight = shapeMiddleRight = sf.drawings.transformPointByMatrix(matrix, shapeMiddleRight);
        shapeElement.corners.bottomLeft = shapeBottomLeft = sf.drawings.transformPointByMatrix(matrix, shapeBottomLeft);
        shapeElement.corners.bottomCenter = shapeBottomCenter = sf.drawings.transformPointByMatrix(matrix, shapeBottomCenter);
        shapeElement.corners.bottomRight = shapeBottomRight = sf.drawings.transformPointByMatrix(matrix, shapeBottomRight); //Set corners based on rotate angle
      }

      shapeBounds = sf.drawings.Rect.toBounds([shapeTopLeft, shapeTopRight, shapeBottomLeft, shapeBottomRight]);
      shapeElement.corners.left = shapeBounds.left;
      shapeElement.corners.right = shapeBounds.right;
      shapeElement.corners.top = shapeBounds.top;
      shapeElement.corners.bottom = shapeBounds.bottom;
      shapeElement.corners.center = shapeBounds.center;
      shapeElement.corners.width = shapeBounds.width;
      shapeElement.corners.height = shapeBounds.height;
      return shapeBounds;
    };
    /**
     * @private
     */


    Drawing.prototype.getShapePoint = function (x, y, w, h, angle, offsetX, offsetY, cornerPoint) {
      var pivotPoint = {
        x: 0,
        y: 0
      };
      var transformMatrix = sf.drawings.identityMatrix();
      sf.drawings.rotateMatrix(transformMatrix, angle, offsetX, offsetY);

      switch (cornerPoint.x) {
        case 1:
          switch (cornerPoint.y) {
            case 1:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w,
                y: y + h
              });
              break;

            case 0:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w,
                y: y
              });
              break;

            case 0.5:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w,
                y: y + h / 2
              });
              break;
          }

          break;

        case 0:
          switch (cornerPoint.y) {
            case 0.5:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x,
                y: y + h / 2
              });
              break;

            case 1:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x,
                y: y + h
              });
              break;

            case 0:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x,
                y: y
              });
              break;
          }

          break;

        case 0.5:
          switch (cornerPoint.y) {
            case 0:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w / 2,
                y: y
              });
              break;

            case 0.5:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w / 2,
                y: y + h / 2
              });
              break;

            case 1:
              pivotPoint = sf.drawings.transformPointByMatrix(transformMatrix, {
                x: x + w / 2,
                y: y + h
              });
              break;
          }

          break;
      }

      return {
        x: pivotPoint.x,
        y: pivotPoint.y
      };
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length


    Drawing.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId, currentSelector) {
      var selectorModel;
      var connector;
      var tx;
      var ty;

      if (obj instanceof Selector) {
        selectorModel = obj;
        connector = selectorModel.annotations[0];
      } else {
        connector = obj;
      }

      point = {
        x: point.x / this.pdfViewer.viewerBase.getZoomFactor(),
        y: point.y / this.pdfViewer.viewerBase.getZoomFactor()
      };

      if (this.checkBoundaryConstraints(undefined, undefined, connector.pageIndex, connector.wrapper.bounds)) {
        if (connector.shapeAnnotationType === 'Distance') {
          var leader = isLeader(connector, endPoint);

          if (endPoint === 'Leader0') {
            tx = point.x - leader.point.x;
            ty = point.y - leader.point.y;
            connector.vertexPoints[0].x += tx;
            connector.vertexPoints[0].y += ty;
          } else if (endPoint === 'Leader1') {
            var length_2 = connector.vertexPoints.length - 1;
            tx = point.x - leader.point.x;
            ty = point.y - leader.point.y;
            connector.vertexPoints[length_2].x += tx;
            connector.vertexPoints[length_2].y += ty;
          } else {
            var angle = sf.drawings.Point.findAngle(connector.sourcePoint, connector.targetPoint);
            var center = obj.wrapper.children[0].bounds.center;
            var matrix = sf.drawings.identityMatrix();
            sf.drawings.rotateMatrix(matrix, -angle, center.x, center.y);
            var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, {
              x: point.x,
              y: point.y
            });

            if (endPoint.split('_')[0] === 'ConnectorSegmentPoint') {
              var matrix = sf.drawings.identityMatrix();
              sf.drawings.rotateMatrix(matrix, -angle, center.x, center.y);
              var rotatedPoint1 = sf.drawings.transformPointByMatrix(matrix, connector.vertexPoints[0]);
              var rotatedPoint2 = sf.drawings.transformPointByMatrix(matrix, connector.vertexPoints[connector.vertexPoints.length - 1]);
              ty = rotatedPoint.y - rotatedPoint1.y;

              if (connector.leaderHeight === 0 && connector.leaderHeight != null) {
                connector.leaderHeight = this.pdfViewer.distanceSettings.leaderLength;
              } else {
                connector.leaderHeight += ty;
                rotatedPoint1.y += ty;
                rotatedPoint2.y += ty;
                var matrix = sf.drawings.identityMatrix();
                sf.drawings.rotateMatrix(matrix, angle, center.x, center.y);
                connector.vertexPoints[0] = sf.drawings.transformPointByMatrix(matrix, rotatedPoint1);
                connector.vertexPoints[connector.vertexPoints.length - 1] = sf.drawings.transformPointByMatrix(matrix, rotatedPoint2);
              }
            }
          }
        } else if (endPoint.split('_')[0] === 'ConnectorSegmentPoint') {
          var i = Number(endPoint.split('_')[1]);
          tx = point.x - connector.vertexPoints[i].x;
          ty = point.y - connector.vertexPoints[i].y;
          connector.vertexPoints[i].x += tx;
          connector.vertexPoints[i].y += ty;

          if (connector.vertexPoints.length > 2 && obj.measureType !== 'Perimeter') {
            if (parseFloat(endPoint.split('_')[1]) === 0) {
              connector.vertexPoints[connector.vertexPoints.length - 1].x += tx;
              connector.vertexPoints[connector.vertexPoints.length - 1].y += ty;
            } else if (parseFloat(endPoint.split('_')[1]) === connector.vertexPoints.length - 1) {
              connector.vertexPoints[0].x += tx;
              connector.vertexPoints[0].y += ty;
            }
          }
        }

        this.nodePropertyChange(connector, {
          vertexPoints: connector.vertexPoints
        });
        this.renderSelector(connector.pageIndex, currentSelector);
      }

      this.pdfViewer.renderDrawing();
      return true;
    };
    /**
     * @private
     */


    Drawing.prototype.dragSourceEnd = function (obj, tx, ty, i) {
      var connector = this.pdfViewer.nameTable[obj.id];
      connector.vertexPoints[i].x += tx;
      connector.vertexPoints[i].y += ty;
      this.pdfViewer.renderDrawing();
      return true;
    };
    /**
     * @private
     */


    Drawing.prototype.updateConnector = function (connector, points) {
      var srcPoint;
      var anglePoint;
      var targetPoint;
      connector.vertexPoints = points;
      updateSegmentElement(connector, points, connector.wrapper.children[0]);
      srcPoint = connector.sourcePoint;
      anglePoint = connector.vertexPoints; //  points = this.clipDecorators(connector, points);

      var element = connector.wrapper.children[0];
      element.canMeasurePath = true;

      for (var i = 0; i < connector.wrapper.children.length; i++) {
        element = connector.wrapper.children[i];

        if (connector.shapeAnnotationType !== 'Polygon') {
          if (element.id.indexOf('srcDec') > -1) {
            updateDecoratorElement(connector, element, points[0], anglePoint[1], true);
          }

          targetPoint = connector.targetPoint;

          if (element.id.indexOf('tarDec') > -1) {
            updateDecoratorElement(connector, element, points[points.length - 1], anglePoint[anglePoint.length - 2], false);
          }
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.copy = function () {
      this.pdfViewer.clipboardData.pasteIndex = 1;
      this.pdfViewer.clipboardData.clipObject = this.copyObjects();
      return this.pdfViewer.clipboardData.clipObject;
    };
    /**
     * @private
     */


    Drawing.prototype.copyObjects = function () {
      var selectedItems = [];
      var obj = [];
      this.pdfViewer.clipboardData.childTable = {};

      if (this.pdfViewer.selectedItems.annotations.length > 0) {
        selectedItems = this.pdfViewer.selectedItems.annotations;

        for (var j = 0; j < selectedItems.length; j++) {
          var element = void 0;
          element = cloneObject(selectedItems[j]);
          obj.push(element);
        }
      }

      if (this.pdfViewer.clipboardData.pasteIndex === 0) {
        //  this.startGroupAction();
        for (var _i = 0, selectedItems_1 = selectedItems; _i < selectedItems_1.length; _i++) {
          var item = selectedItems_1[_i];

          if (this.pdfViewer.nameTable[item.id]) {
            this.pdfViewer.remove(item);
          }
        } //this.endGroupAction();

      }

      this.sortByZIndex(obj, 'zIndex');
      return obj;
    };

    Drawing.prototype.getNewObject = function (obj) {
      var newObj;
      var newobjs = [];
      this.pdfViewer.clipboardData.pasteIndex = 1;

      for (var i = 0; i < obj.length; i++) {
        newObj = cloneObject(obj[i]);
        newobjs.push(newObj);
      }

      return newobjs;
    };
    /**
     * @private
     */


    Drawing.prototype.paste = function (obj, index) {
      if (obj || this.pdfViewer.clipboardData.clipObject) {
        var copiedItems = obj ? this.getNewObject(obj) : this.pdfViewer.clipboardData.clipObject;

        if (copiedItems) {
          var multiSelect = copiedItems.length !== 1;
          var objectTable = {};

          if (this.pdfViewer.clipboardData.pasteIndex !== 0) {
            this.pdfViewer.clearSelection(index);
          }

          for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {
            var copy = copiedItems_1[_i];
            objectTable[copy.id] = copy;
          }

          for (var j = 0; j < copiedItems.length; j++) {
            var copy = copiedItems[j];
            var pageDiv = this.pdfViewer.viewerBase.getElement('_pageDiv_' + copy.pageIndex);
            var events = event;

            if (isLineShapes(copy)) {
              this.calculateCopyPosition(copy, pageDiv, events);
            } else {
              if (pageDiv) {
                var pageCurrentRect = pageDiv.getBoundingClientRect();
                copy.bounds.x = events.clientX - pageCurrentRect.left;
                copy.bounds.y = events.clientY - pageCurrentRect.top;
              }
            }

            var newNode = cloneObject(copy);

            if (this.pdfViewer.viewerBase.contextMenuModule.previousAction !== 'Cut') {
              newNode.id += sf.drawings.randomId();

              if (this.pdfViewer.annotationModule) {
                newNode.annotName = newNode.id;
                this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAnnotationCollection(newNode, copiedItems[0]);
              } // tslint:disable-next-line:max-line-length


              this.pdfViewer.annotation.addAction(newNode.pageIndex, null, newNode, 'Addition', '', newNode, newNode);
            }

            var addedAnnot = this.add(newNode);

            if ((newNode.shapeAnnotationType === 'FreeText' || newNode.enableShapeLabel) && addedAnnot) {
              this.nodePropertyChange(addedAnnot, {});
            }

            this.pdfViewer.select([newNode.id], this.pdfViewer.annotationSelectorSettings);
          }
        }

        this.pdfViewer.renderDrawing(undefined, index);
        this.pdfViewer.clipboardData.pasteIndex++;
      }
    };

    Drawing.prototype.calculateCopyPosition = function (copy, pageDiv, events) {
      var x1;
      var y1;
      var x2;
      var y2;

      for (var i = 0; i < copy.vertexPoints.length; i++) {
        if (pageDiv) {
          if (i === 0) {
            var pageCurrentRect = pageDiv.getBoundingClientRect();
            x1 = copy.vertexPoints[i].x;
            y1 = copy.vertexPoints[i].y;
            copy.vertexPoints[i].x = events.clientX - pageCurrentRect.left;
            copy.vertexPoints[i].y = events.clientY - pageCurrentRect.top;
            x2 = copy.vertexPoints[i].x;
            y2 = copy.vertexPoints[i].y;
          } else {
            copy.vertexPoints[i].x += x2 - x1;
            copy.vertexPoints[i].y += y2 - y1;
          }
        }
      }
    };
    /**
     * @private
     */


    Drawing.prototype.cut = function (index) {
      this.pdfViewer.clipboardData.pasteIndex = 0;
      this.pdfViewer.clipboardData.clipObject = this.copyObjects();
      this.pdfViewer.renderDrawing(undefined, index);
    };
    /**
     * @private
     */


    Drawing.prototype.sortByZIndex = function (nodeArray, sortID) {
      var id = sortID ? sortID : 'zIndex';
      nodeArray = nodeArray.sort(function (a, b) {
        return a[id] - b[id];
      });
      return nodeArray;
    };

    return Drawing;
  }();

  var __extends$2 = undefined && undefined.__extends || function () {
    var _extendStatics3 = function extendStatics(d, b) {
      _extendStatics3 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics3(d, b);
    };

    return function (d, b) {
      _extendStatics3(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  /**
   * Defines the interactive tools
   * @hidden
   */


  var ToolBase =
  /** @class */
  function () {
    /**
     * Initializes the tool
     * @param command Command that is corresponding to the current action
     */
    function ToolBase(pdfViewer, pdfViewerBase, protectChange) {
      if (protectChange === void 0) {
        protectChange = false;
      }
      /**
       * Command that is corresponding to the current action
       */


      this.commandHandler = null;
      /**
       * Sets/Gets whether the interaction is being done
       */

      this.inAction = false;
      /**
       * Sets/Gets the protect change
       */

      this.pdfViewerBase = null;
      /**
       * Sets/Gets the current element that is under mouse
       */

      /**   @private  */

      this.currentElement = null;
      /**   @private  */

      this.blocked = false;
      this.isTooltipVisible = false;
      /** @private */

      this.childTable = {};
      /** @private */

      this.helper = undefined;
      /**
       * Sets/Gets the previous object when mouse down
       */

      this.undoElement = {
        annotations: []
      };
      this.undoParentElement = {
        annotations: []
      };
      this.commandHandler = pdfViewer;
      this.pdfViewerBase = pdfViewerBase;
    }

    ToolBase.prototype.startAction = function (currentElement) {
      this.currentElement = currentElement;
      this.inAction = true;
    };
    /**   @private  */


    ToolBase.prototype.mouseDown = function (args) {
      this.currentElement = args.source;
      this.startPosition = this.currentPosition = this.prevPosition = args.position;
      this.isTooltipVisible = true;
      this.startAction(args.source);
    };
    /**   @private  */


    ToolBase.prototype.mouseMove = function (args) {
      this.currentPosition = args.position; //this.currentElement = currentElement;

      this.prevPageId = this.pdfViewerBase.activeElements.activePageID;
      return !this.blocked;
    };
    /**   @private  */


    ToolBase.prototype.mouseUp = function (args) {
      this.currentPosition = args.position; // this.currentElement = currentElement;

      this.isTooltipVisible = false; //At the end

      this.endAction();
      this.helper = null;
    };

    ToolBase.prototype.endAction = function () {
      //remove helper  
      if (this.commandHandler) {
        this.commandHandler.tool = '';

        if (this.helper) {
          this.commandHandler.remove(this.helper);
        }
      }

      this.commandHandler = null;
      this.currentElement = null;
      this.currentPosition = null;
      this.inAction = false;
      this.blocked = false;
    };
    /**   @private  */


    ToolBase.prototype.mouseWheel = function (args) {
      this.currentPosition = args.position;
    };
    /**   @private  */


    ToolBase.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    }; // tslint:disable-next-line


    ToolBase.prototype.updateSize = function ( // tslint:disable-next-line
    shape, startPoint, endPoint, corner, initialBounds, angle, isMouseUp) {
      shape = shape;
      var zoom = this.commandHandler.viewerBase.getZoomFactor();
      var difx = this.currentPosition.x / zoom - this.startPosition.x / zoom;
      var dify = this.currentPosition.y / zoom - this.startPosition.y / zoom;
      var rotateAngle = shape instanceof sf.drawings.TextElement ? angle : shape.rotateAngle;
      var matrix;
      matrix = sf.drawings.identityMatrix();
      sf.drawings.rotateMatrix(matrix, -rotateAngle, 0, 0);
      var deltaWidth = 0;
      var deltaHeight = 0;
      var diff;
      var width = shape instanceof sf.drawings.TextElement ? shape.actualSize.width : shape.wrapper.bounds.width;
      var height = shape instanceof sf.drawings.TextElement ? shape.actualSize.height : shape.wrapper.bounds.height; // tslint:disable-next-line

      var obj = shape;

      if (!shape.annotName && !shape.shapeAnnotationType) {
        if (shape) {
          // tslint:disable-next-line
          obj = shape.annotations[0];
        }
      } // tslint:disable-next-line


      var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(obj);
      var annotationMaxHeight = 0;
      var annotationMaxWidth = 0;
      var annotationMinHeight = 0;
      var annotationMinWidth = 0;

      if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {
        annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
        annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;
        annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;
        annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;
      }

      var isAnnotationSet = false;

      if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {
        isAnnotationSet = true;
      }

      if (isAnnotationSet && isMouseUp) {
        // tslint:disable-next-line
        var size = this.getPositions(corner, difx, dify);
        var newWidth = width + size.x;
        var newHeight = height + size.y; // tslint:disable-next-line:max-line-length

        if (newHeight > annotationMinHeight && newHeight < annotationMaxHeight && newWidth > annotationMinWidth && newWidth < annotationMaxWidth) {
          difx = difx;
          dify = dify;
        } else {
          if (newHeight < annotationMinHeight || newHeight > annotationMaxHeight) {
            if (newHeight < annotationMinHeight) {
              dify = annotationMinHeight - height;
            } else {
              dify = annotationMaxHeight - height;
            }
          }

          if (newWidth < annotationMinWidth || newWidth > annotationMaxWidth) {
            if (newWidth < annotationMinWidth) {
              difx = annotationMinWidth - width;
            } else {
              difx = annotationMaxWidth - width;
            }
          }
        }
      }

      switch (corner) {
        case 'ResizeWest':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;
          deltaHeight = 1;
          difx = difx;
          dify = 0;

          if (isAnnotationSet) {
            if (initialBounds.width - difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }
          }

          deltaWidth = (initialBounds.width - difx) / width;
          break;

        case 'ResizeEast':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;
          dify = 0;

          if (isAnnotationSet) {
            if (initialBounds.width + difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }
          }

          deltaWidth = (initialBounds.width + difx) / width;
          deltaHeight = 1;
          break;

        case 'ResizeNorth':
          deltaWidth = 1;
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.height - dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaHeight = (initialBounds.height - dify) / height;
          break;

        case 'ResizeSouth':
          deltaWidth = 1;
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.height + dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaHeight = (initialBounds.height + dify) / height;
          break;

        case 'ResizeNorthEast':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.width + difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }

            if (initialBounds.height - dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaWidth = (initialBounds.width + difx) / width;
          deltaHeight = (initialBounds.height - dify) / height;
          break;

        case 'ResizeNorthWest':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.width - difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }

            if (initialBounds.height - dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaWidth = (initialBounds.width - difx) / width;
          deltaHeight = (initialBounds.height - dify) / height;
          break;

        case 'ResizeSouthEast':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.width + difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }

            if (initialBounds.height + dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaHeight = (initialBounds.height + dify) / height;
          deltaWidth = (initialBounds.width + difx) / width;
          break;

        case 'ResizeSouthWest':
          diff = sf.drawings.transformPointByMatrix(matrix, {
            x: difx,
            y: dify
          });
          difx = diff.x;
          dify = diff.y;

          if (isAnnotationSet) {
            if (initialBounds.width - difx > annotationMaxWidth) {
              difx = annotationMaxWidth - initialBounds.width;
            }

            if (initialBounds.height + dify > annotationMaxHeight) {
              dify = annotationMaxHeight - initialBounds.height;
            }
          }

          deltaWidth = (initialBounds.width - difx) / width;
          deltaHeight = (initialBounds.height + dify) / height;
          break;
      }

      return {
        width: deltaWidth,
        height: deltaHeight
      };
    };

    ToolBase.prototype.getPivot = function (corner) {
      switch (corner) {
        case 'ResizeWest':
          return {
            x: 1,
            y: 0.5
          };

        case 'ResizeEast':
          return {
            x: 0,
            y: 0.5
          };

        case 'ResizeNorth':
          return {
            x: 0.5,
            y: 1
          };

        case 'ResizeSouth':
          return {
            x: 0.5,
            y: 0
          };

        case 'ResizeNorthEast':
          return {
            x: 0,
            y: 1
          };

        case 'ResizeNorthWest':
          return {
            x: 1,
            y: 1
          };

        case 'ResizeSouthEast':
          return {
            x: 0,
            y: 0
          };

        case 'ResizeSouthWest':
          return {
            x: 1,
            y: 0
          };
      }

      return {
        x: 0.5,
        y: 0.5
      };
    };

    ToolBase.prototype.getPositions = function (corner, x, y) {
      switch (corner) {
        case 'ResizeEast':
          return {
            x: x,
            y: 0
          };

        case 'ResizeSouthEast':
          return {
            x: x,
            y: y
          };

        case 'ResizeSouth':
          return {
            x: 0,
            y: y
          };

        case 'ResizeNorth':
          return {
            x: 0,
            y: -y
          };

        case 'ResizeNorthEast':
          return {
            x: x,
            y: -y
          };

        case 'ResizeNorthWest':
          return {
            x: -x,
            y: -y
          };

        case 'ResizeWest':
          return {
            x: -x,
            y: 0
          };

        case 'ResizeSouthWest':
          return {
            x: -x,
            y: y
          };
      }

      return {
        x: x,
        y: y
      };
    };

    return ToolBase;
  }();
  /**
   * Helps to select the objects
   * @hidden
   */


  var SelectTool =
  /** @class */
  function (_super) {
    __extends$2(SelectTool, _super);

    function SelectTool(commandHandler, base) {
      return _super.call(this, commandHandler, base, true) || this; //     this.action = action;
    }
    /**   @private  */


    SelectTool.prototype.mouseDown = function (args) {
      this.inAction = true;
      this.mouseEventHelper(args);

      _super.prototype.mouseDown.call(this, args);
    };

    SelectTool.prototype.mouseEventHelper = function (args) {
      if (this.commandHandler && this.commandHandler.annotationModule) {
        // tslint:disable-next-line
        this.commandHandler.annotationModule.overlappedCollections = findActiveElement(args, this.pdfViewerBase, this.commandHandler, true);
      } // tslint:disable-next-line


      var object = findActiveElement(args, this.pdfViewerBase, this.commandHandler); // tslint:disable-next-line

      var currentSelctor;

      if (args.source && args.annotationSelectorSettings !== null) {
        currentSelctor = args.source.annotationSelectorSettings;
      } else {
        currentSelctor = '';
      }

      if (this.commandHandler) {
        var selectedObject = this.commandHandler.selectedItems;
        var currentSource = args.source;

        if (selectedObject.annotations.length && args.info && !args.info.ctrlKey // tslint:disable-next-line
        && this.commandHandler.annotationModule && this.commandHandler.annotationModule.freeTextAnnotationModule.isInuptBoxInFocus === false) {
          this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID); // tslint:disable-next-line:max-line-length
        } else if (args.info && args.info.ctrlKey && (currentSource && currentSource.shapeAnnotationType === 'FreeText' || this.commandHandler.selectedItems.annotations[0] && this.commandHandler.selectedItems.annotations[0].shapeAnnotationType === 'FreeText')) {
          this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
        }

        if (object) {
          this.commandHandler.select([object.id], currentSelctor);
          this.commandHandler.viewerBase.isAnnotationMouseDown = true;
        }
      }
    };
    /**   @private  */


    SelectTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args); //draw selected region


      return !this.blocked;
    };
    /**   @private  */


    SelectTool.prototype.mouseUp = function (args) {
      // tslint:disable-next-line
      this.mouseEventHelper(args);
      this.inAction = false;

      _super.prototype.mouseUp.call(this, args);
    };
    /**   @private  */


    SelectTool.prototype.mouseLeave = function (args) {
      if (this.inAction) {
        this.mouseUp(args);
      }
    };

    return SelectTool;
  }(ToolBase);
  /** @hidden */


  var MoveTool =
  /** @class */
  function (_super) {
    __extends$2(MoveTool, _super);

    function MoveTool(commandHandler, base) {
      var _this = _super.call(this, commandHandler, base) || this;
      /**   @private  */


      _this.currentTarget = null;
      /**   @private  */

      _this.prevNode = null;
      return _this;
    }
    /**   @private  */


    MoveTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseDown.call(this, args);

      this.offset = {
        x: args.source.wrapper.offsetX,
        y: args.source.wrapper.offsetY
      };
      this.startPosition = args.position;
      var nodeMouseDown = cloneObject(args.source);
      this.redoElement = {
        bounds: {
          x: nodeMouseDown.wrapper.offsetX,
          y: nodeMouseDown.wrapper.offsetY,
          width: nodeMouseDown.wrapper.actualSize.width,
          height: nodeMouseDown.wrapper.actualSize.height
        } // tslint:disable-next-line

      };

      if (isLineShapes(nodeMouseDown)) {
        this.redoElement.vertexPoints = nodeMouseDown.vertexPoints;
        this.redoElement.leaderHeight = nodeMouseDown.leaderHeight;
      }

      this.inAction = true;
    };
    /**   @private  */

    /* tslint:disable */


    MoveTool.prototype.mouseUp = function (args) {
      if (this.commandHandler) {
        if (this.commandHandler.selectedItems && this.commandHandler.selectedItems.annotations) {
          if (this.commandHandler.selectedItems.annotations[0].annotName === args.source.annotName) {
            this.commandHandler.viewerBase.isAnnotationMouseMove = true;
          }
        } else {
          this.commandHandler.viewerBase.isAnnotationMouseMove = false;
        }

        var currentSelctor = args.source.annotationSelectorSettings;
        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
        this.commandHandler.select([args.source.id], currentSelctor);
        this.commandHandler.dragSelectedObjects(this.calculateMouseActionXDiff(args), this.calculateMouseActionYDiff(args), this.pdfViewerBase.activeElements.activePageID, currentSelctor, null);
        this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor);
        this.commandHandler.viewerBase.isAnnotationMouseMove = false; // tslint:disable-next-line

        var newShapeObject = {
          bounds: {
            x: args.source.wrapper.offsetX,
            y: args.source.wrapper.offsetY,
            width: args.source.wrapper.actualSize.width,
            height: args.source.wrapper.actualSize.height
          },
          modifiedDate: args.source.modifiedDate
        };

        if (isLineShapes(args.source)) {
          newShapeObject.vertexPoints = args.source.vertexPoints;
          newShapeObject.leaderHeight = args.source.leaderHeight;
        } // tslint:disable-next-line


        this.commandHandler.annotation.addAction(this.pageIndex, null, args.source, 'Drag', '', this.redoElement, newShapeObject);
        this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, null, 'Drag');
        this.commandHandler.annotation.stickyNotesAnnotationModule.updateStickyNotes(args.source, null);
      }

      _super.prototype.mouseUp.call(this, args);
    };

    MoveTool.prototype.calculateMouseXDiff = function () {
      if (this.currentPosition && this.startPosition) {
        return this.currentPosition.x - this.startPosition.x;
      } else {
        return 0;
      }
    };

    MoveTool.prototype.calculateMouseYDiff = function () {
      if (this.currentPosition && this.startPosition) {
        return this.currentPosition.y - this.startPosition.y;
      } else {
        return 0;
      }
    };

    MoveTool.prototype.calculateMouseActionXDiff = function (args) {
      var x = this.calculateMouseXDiff() / this.commandHandler.viewerBase.getZoomFactor(); // let y: number = this.calculateMouseYDiff() / this.commandHandler.magnification.zoomFactor;

      if (this.offset) {
        var requiredX = this.offset.x + x; // let requiredY: number = this.offset.y + y;

        return requiredX - args.source.wrapper.offsetX; //let diffY: number = requiredY - args.source.wrapper.offsetY;
      } else {
        return 0;
      }
    };

    MoveTool.prototype.calculateMouseActionYDiff = function (args) {
      // let x: number = this.calculateMouseXDiff() / this.commandHandler.magnification.zoomFactor;
      var y = this.calculateMouseYDiff() / this.commandHandler.viewerBase.getZoomFactor();

      if (this.offset) {
        // let requiredX: number = this.offset.x + x;
        var requiredY = this.offset.y + y; // let diffX: number = requiredX - args.source.wrapper.offsetX;

        return requiredY - args.source.wrapper.offsetY;
      } else {
        return 0;
      }
    };
    /**   @private  */

    /* tslint:disable */


    MoveTool.prototype.mouseMove = function (args, isStamp) {
      _super.prototype.mouseMove.call(this, args);

      if (this.inAction) {
        this.currentPosition = args.position;
        this.currentTarget = args.target;
        var currentSelctor = args.source.annotationSelectorSettings;
        var x = this.calculateMouseXDiff() / this.commandHandler.viewerBase.getZoomFactor();
        var y = this.calculateMouseYDiff() / this.commandHandler.viewerBase.getZoomFactor();
        var requiredX = this.offset.x + x;
        var requiredY = this.offset.y + y;
        var diffX = this.calculateMouseActionXDiff(args);
        var diffY = this.calculateMouseActionYDiff(args);

        if (!this.helper) {
          var selectedItem = this.commandHandler.selectedItems.annotations[0]; // tslint:disable-next-line

          var cobject = cloneObject(this.commandHandler.selectedItems.annotations[0]);

          if (cobject.wrapper) {
            diffX = requiredX - cobject.wrapper.offsetX;
            diffY = requiredY - cobject.wrapper.offsetY;
            cobject.bounds = this.commandHandler.selectedItems.annotations[0].wrapper.bounds;
          }

          cobject.wrapper = undefined;
          cobject.id = 'diagram_helper';

          if (cobject.shapeAnnotationType === 'Stamp') {
            cobject.strokeColor = '';
            cobject.borderDashArray = '';
            cobject.fillColor = 'transparent';
            cobject.stampFillColor = 'transparent';
            cobject.data = '';
          } else if (cobject.shapeAnnotationType === 'FreeText') {
            cobject.strokeColor = 'blue';
            cobject.fillColor = 'transparent';
            cobject.thickness = 1;
            cobject.opacity = 1;
            cobject.dynamicText = '';
          } else {
            cobject.strokeColor = 'red';
            cobject.borderDashArray = '5,5';
            cobject.fillColor = 'transparent';
            cobject.thickness = 2;
            cobject.opacity = 1;
          }

          if (cobject.enableShapeLabel === true) {
            cobject.labelContent = '';
          }

          if (!isStamp) {
            this.helper = cobject = this.commandHandler.add(cobject);
          } else {
            cobject = this.helper = args.source;
          }

          this.commandHandler.selectedItems.annotations = [cobject];
        } else {
          diffX = requiredX - this.helper.wrapper.offsetX;
          diffY = requiredY - this.helper.wrapper.offsetY;
        }

        if (this.helper && this.helper.shapeAnnotationType === 'Stamp') {
          isStamp = true;
        } // tslint:disable-next-line:max-line-length


        if (this.commandHandler.checkBoundaryConstraints(diffX, diffY, this.pdfViewerBase.activeElements.activePageID, this.helper.wrapper.bounds, isStamp)) {
          this.commandHandler.dragSelectedObjects(diffX, diffY, this.pdfViewerBase.activeElements.activePageID, currentSelctor, this.helper);
          this.prevNode = this.helper;
          this.prevPosition = this.currentPosition;
        } else {
          this.currentPosition = this.prevPosition;
        }
      }

      return true;
    };
    /**   @private  */


    MoveTool.prototype.mouseLeave = function (args) {
      var currentSelctor = args.source.annotationSelectorSettings;
      var requiredX = this.offset.x + this.calculateMouseXDiff();
      var requiredY = this.offset.y + this.calculateMouseYDiff();
      var diffX = requiredX - args.source.wrapper.offsetX;
      var diffY = requiredY - args.source.wrapper.offsetY;
      this.commandHandler.dragSelectedObjects(diffX, diffY, this.prevPageId, currentSelctor, null);
      this.commandHandler.renderSelector(this.prevPageId, currentSelctor);

      _super.prototype.mouseLeave.call(this, args);
    };
    /**   @private  */


    MoveTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);

      this.currentTarget = null;
      this.prevPosition = null;
    };

    return MoveTool;
  }(ToolBase);
  /** @hidden */


  var StampTool =
  /** @class */
  function (_super) {
    __extends$2(StampTool, _super);

    function StampTool() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**   @private  */
    // tslint:disable-next-line


    StampTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseUp.call(this, args);
    };
    /**   @private  */


    StampTool.prototype.mouseMove = function (args) {
      // tslint:disable-next-line
      var newObject;

      if (!this.inAction) {
        var pageIndex = this.pdfViewerBase.activeElements.activePageID;
        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID); // tslint:disable-next-line:max-line-length

        var nodeElement = this.commandHandler.annotation.stampAnnotationModule.moveStampElement(args.position.x, args.position.y, pageIndex);
        newObject = this.commandHandler.add(nodeElement);
        args.source = this.commandHandler.annotations[this.commandHandler.annotations.length - 1];
        args.sourceWrapper = args.source.wrapper;
        this.inAction = true; // tslint:disable-next-line

        var currentSource = args.source;

        if (currentSource && currentSource.shapeAnnotationType === 'HandWrittenSignature') {
          // tslint:disable-next-line:max-line-length
          // tslint:disable-next-line
          this['offset'] = {
            x: args.source.wrapper.offsetX - args.source.wrapper.bounds.width / 2,
            y: args.source.wrapper.offsetY - args.source.wrapper.bounds.height / 2
          };
        } else {
          // tslint:disable-next-line
          this['offset'] = {
            x: args.source.wrapper.offsetX,
            y: args.source.wrapper.offsetY
          };
        }

        this.startPosition = args.position;
        this.commandHandler.select([newObject.id]);
      }

      var currentSelctor = args.source.annotationSelectorSettings;

      _super.prototype.mouseMove.call(this, args, true);

      this.commandHandler.renderSelector(args.source.pageIndex, currentSelctor);
      return this.inAction;
    };

    return StampTool;
  }(MoveTool);
  /**
   * Draws a node that is defined by the user
   * @hidden
   */


  var InkDrawingTool =
  /** @class */
  function (_super) {
    __extends$2(InkDrawingTool, _super);

    function InkDrawingTool(commandHandler, base, sourceObject) {
      var _this = _super.call(this, commandHandler, base) || this;

      _this.sourceObject = sourceObject;
      return _this;
    }
    /**   @private  */


    InkDrawingTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseDown.call(this, args);

      this.inAction = true; // tslint:disable-next-line

      var node = {
        currentPosition: this.currentPosition,
        prevPosition: this.prevPosition
      };
      this.commandHandler.annotation.inkAnnotationModule.drawInkInCanvas(node, this.pdfViewerBase.activeElements.activePageID);
    };
    /**   @private  */


    InkDrawingTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      if (this.inAction) {
        // tslint:disable-next-line
        var node = {
          currentPosition: this.currentPosition,
          prevPosition: this.pdfViewerBase.prevPosition
        };
        this.commandHandler.annotation.inkAnnotationModule.drawInkInCanvas(node, this.pdfViewerBase.activeElements.activePageID);
      }

      return this.inAction;
    };
    /**   @private  */


    InkDrawingTool.prototype.mouseUp = function (args) {
      this.pdfViewerBase.isInkAdded = true;
      this.commandHandler.annotation.inkAnnotationModule.mouseX = this.currentPosition.x;
      this.commandHandler.annotation.inkAnnotationModule.mouseY = this.currentPosition.y;
      var currentAnnot = this.commandHandler.annotation.inkAnnotationModule.addInk();
      this.commandHandler.renderDrawing(undefined, this.pdfViewerBase.activeElements.activePageID);
      this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
      this.commandHandler.select([currentAnnot.id], currentAnnot.annotationSelectorSettings);
      this.pdfViewerBase.isInkAdded = false;

      _super.prototype.mouseUp.call(this, args);

      return true;
    };
    /**   @private  */


    InkDrawingTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    };
    /**   @private  */


    InkDrawingTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);
    };

    return InkDrawingTool;
  }(ToolBase);
  /**
   * Helps to edit the selected connectors
   * @hidden
   */


  var ConnectTool =
  /** @class */
  function (_super) {
    __extends$2(ConnectTool, _super);

    function ConnectTool(commandHandler, base, endPoint) {
      var _this = _super.call(this, commandHandler, base, true) || this;

      _this.endPoint = endPoint;
      return _this;
    }
    /**   @private  */


    ConnectTool.prototype.mouseDown = function (args) {
      this.inAction = true;
      this.undoElement = undefined;

      _super.prototype.mouseDown.call(this, args);

      var oldValue;
      var connectors;

      if (args.source && args.source.annotations) {
        oldValue = {
          x: this.prevPosition.x,
          y: this.prevPosition.y
        };
        connectors = args.source.annotations[0];
      }

      this.initialPosition = args.position;
      this.prevSource = this.commandHandler.selectedItems.annotations[0];
      var nodeElement = cloneObject(args.source);
      this.redoElement = {
        bounds: {
          x: nodeElement.wrapper.offsetX,
          y: nodeElement.wrapper.offsetY,
          width: nodeElement.wrapper.actualSize.width,
          height: nodeElement.wrapper.actualSize.height
        } // tslint:disable-next-line

      };

      if (isLineShapes(nodeElement)) {
        this.redoElement.vertexPoints = nodeElement.vertexPoints;
        this.redoElement.leaderHeight = nodeElement.leaderHeight; // tslint:disable-next-line:max-line-length

        if (nodeElement.measureType === 'Distance' || nodeElement.measureType === 'Perimeter' || nodeElement.measureType === 'Area' || nodeElement.measureType === 'Volume') {
          this.redoElement.notes = nodeElement.notes;
        }
      }

      this.currentPosition = args.position;
    };
    /**   @private  */


    ConnectTool.prototype.mouseUp = function (args) {
      if (this.commandHandler) {
        var node = this.commandHandler.selectedItems.annotations[0];

        if (node) {
          // tslint:disable-next-line
          var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(node);
          var annotationMaxHeight = 0;
          var annotationMaxWidth = 0;
          var annotationMinHeight = 0;
          var annotationMinWidth = 0; // tslint:disable-next-line:max-line-length

          if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {
            annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;
            annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;
            annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;
          }

          if (node.vertexPoints.length > 3) {
            // tslint:disable-next-line
            var sizeObject = this.commandHandler.viewerBase.checkAnnotationWidth(node.vertexPoints);
            var width = sizeObject.width;
            var height = sizeObject.height;

            if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {
              // tslint:disable-next-line:max-line-length
              if (height > annotationMinHeight && height < annotationMaxHeight || width > annotationMinWidth && width < annotationMaxWidth) {
                // tslint:disable-next-line:max-line-length
                this.commandHandler.nodePropertyChange(this.prevSource, {
                  vertexPoints: node.vertexPoints,
                  leaderHeight: node.leaderHeight
                });
              }
            } else {
              // tslint:disable-next-line:max-line-length
              this.commandHandler.nodePropertyChange(this.prevSource, {
                vertexPoints: node.vertexPoints,
                leaderHeight: node.leaderHeight
              });
            }
          } else {
            if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {
              if (node.shapeAnnotationType === 'Line' || 'Distance' || 'LineWidthArrowHead') {
                var x = 0;
                var y = 0;

                if (node.vertexPoints[0].x > node.vertexPoints[1].x) {
                  x = node.vertexPoints[0].x - node.vertexPoints[1].x;
                } else {
                  x = node.vertexPoints[1].x - node.vertexPoints[0].x;
                }

                if (node.vertexPoints[0].y > node.vertexPoints[1].y) {
                  y = node.vertexPoints[0].y - node.vertexPoints[1].y;
                } else {
                  y = node.vertexPoints[1].y - node.vertexPoints[0].y;
                }

                var diff = x > y ? x : y;

                if (diff < (annotationMaxHeight || annotationMaxWidth) && diff > (annotationMinHeight || annotationMinWidth)) {
                  // tslint:disable-next-line:max-line-length
                  this.commandHandler.nodePropertyChange(this.prevSource, {
                    vertexPoints: node.vertexPoints,
                    leaderHeight: node.leaderHeight
                  });
                }
              } else {
                // tslint:disable-next-line:max-line-length
                this.commandHandler.nodePropertyChange(this.prevSource, {
                  vertexPoints: node.vertexPoints,
                  leaderHeight: node.leaderHeight
                });
              }
            } else {
              // tslint:disable-next-line:max-line-length
              this.commandHandler.nodePropertyChange(this.prevSource, {
                vertexPoints: node.vertexPoints,
                leaderHeight: node.leaderHeight
              });
            }
          }

          var currentSelctor = args.source.annotationSelectorSettings;
          this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
          this.commandHandler.select([this.prevSource.id], currentSelctor);
          this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor); // tslint:disable-next-line

          var newShapeElementObject = {
            bounds: {
              x: args.source.wrapper.offsetX,
              y: args.source.wrapper.offsetY,
              width: args.source.wrapper.actualSize.width,
              height: args.source.wrapper.actualSize.height
            }
          }; // tslint:disable-next-line:max-line-length

          if (node.measureType === 'Distance' || node.measureType === 'Perimeter' || node.measureType === 'Area' || node.measureType === 'Volume') {
            this.commandHandler.annotation.updateCalibrateValues(this.commandHandler.selectedItems.annotations[0]);
            newShapeElementObject.notes = args.source.notes;
          }

          if (isLineShapes(args.source)) {
            newShapeElementObject.vertexPoints = args.source.vertexPoints;
            newShapeElementObject.leaderHeight = args.source.leaderHeight;
          } // tslint:disable-next-line


          this.commandHandler.annotation.addAction(this.pageIndex, null, this.prevSource, 'Resize', '', this.redoElement, newShapeElementObject);
        }
      }

      _super.prototype.mouseUp.call(this, args);
    };
    /**   @private  */


    ConnectTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      var connector;
      this.currentPosition = args.position;

      if (this.currentPosition && this.prevPosition) {
        var diffX = this.currentPosition.x - this.prevPosition.x;
        var diffY = this.currentPosition.y - this.prevPosition.y;
        var newValue = void 0;
        var oldValue = void 0;

        if (args.source && args.source.annotations) {
          newValue = {
            x: this.currentPosition.x,
            y: this.currentPosition.y
          };
          oldValue = {
            x: this.prevPosition.x,
            y: this.prevPosition.y
          };
          connector = args.source.annotations[0];
        }

        if (this.inAction && this.endPoint !== undefined && diffX !== 0 || diffY !== 0) {
          if (!this.helper) {
            // tslint:disable-next-line
            var cloneShapebject = cloneObject(this.commandHandler.selectedItems.annotations[0]);
            cloneShapebject.id = 'diagram_helper';
            cloneShapebject.strokeColor = 'red';
            cloneShapebject.borderDashArray = '5,5';
            cloneShapebject.fillColor = 'transparent';
            cloneShapebject.thickness = 2;
            cloneShapebject.opacity = 1;

            if (cloneShapebject.enableShapeLabel === true) {
              cloneShapebject.labelContent = '';
            }

            this.helper = cloneShapebject = this.commandHandler.add(cloneShapebject);
            this.commandHandler.selectedItems.annotations = [cloneShapebject];
          }

          var currentSelctor = args.source.annotationSelectorSettings;
          this.blocked = !this.commandHandler.dragConnectorEnds(this.endPoint, this.helper, this.currentPosition, this.selectedSegment, args.target, null, currentSelctor);
          this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor);
        }
      }

      this.prevPosition = this.currentPosition;
      return !this.blocked;
    };
    /**   @private  */


    ConnectTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    };
    /**   @private  */


    ConnectTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);

      this.prevPosition = null;
      this.endPoint = null;
    };

    return ConnectTool;
  }(ToolBase);
  /**
   * Scales the selected objects
   * @hidden
   */


  var ResizeTool =
  /** @class */
  function (_super) {
    __extends$2(ResizeTool, _super);

    function ResizeTool(commandHandler, base, corner) {
      var _this = _super.call(this, commandHandler, base, true) || this;
      /**   @private  */


      _this.initialBounds = new sf.drawings.Rect();
      _this.corner = corner;
      return _this;
    }
    /**   @private  */


    ResizeTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseDown.call(this, args);

      this.initialBounds.x = args.source.wrapper.offsetX;
      this.initialBounds.y = args.source.wrapper.offsetY;
      this.initialBounds.height = args.source.wrapper.actualSize.height;
      this.initialBounds.width = args.source.wrapper.actualSize.width;
      this.initialPosition = args.position;
      var node = cloneObject(args.source);
      this.redoElement = {
        bounds: {
          x: node.wrapper.offsetX,
          y: node.wrapper.offsetY,
          width: node.wrapper.actualSize.width,
          height: node.wrapper.actualSize.height
        } // tslint:disable-next-line

      };

      if (isLineShapes(node)) {
        this.redoElement.vertexPoints = node.vertexPoints;
        this.redoElement.leaderHeight = node.leaderHeight;
      }

      if (node.measureType === 'Radius') {
        this.redoElement.notes = node.notes;
      }

      this.prevSource = this.commandHandler.selectedItems.annotations[0];
    };
    /**   @private  */


    ResizeTool.prototype.mouseUp = function (args, isPreventHistory) {
      var object;
      object = args.source;

      if (this.commandHandler) {
        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
        this.commandHandler.viewerBase.isAnnotationSelect = true;
        this.commandHandler.select([this.prevSource.id], this.prevSource.annotationSelectorSettings); // tslint:disable-next-line:max-line-length

        var deltaValues = this.updateSize(this.prevSource, this.currentPosition, this.initialPosition, this.corner, this.initialBounds, null, true);
        this.blocked = this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.currentPosition, this.initialPosition, this.prevSource);

        if (this.commandHandler.selectedItems && this.commandHandler.selectedItems.annotations && // tslint:disable-next-line:max-line-length
        this.commandHandler.selectedItems.annotations[0] && this.commandHandler.selectedItems.annotations[0].shapeAnnotationType === 'Stamp') {
          if (this.commandHandler.stampSettings.minHeight || this.commandHandler.stampSettings.minWidth) {
            this.commandHandler.select([this.prevSource.id], this.prevSource.annotationSelectorSettings);
          }
        }

        this.commandHandler.renderSelector(this.prevPageId, this.prevSource.annotationSelectorSettings);

        if (this.commandHandler.annotation && args.source.wrapper) {
          // tslint:disable-next-line
          var newObject = {
            bounds: {
              x: args.source.wrapper.offsetX,
              y: args.source.wrapper.offsetY,
              width: args.source.wrapper.actualSize.width,
              height: args.source.wrapper.actualSize.height
            }
          };

          if (isLineShapes(args.source)) {
            newObject.vertexPoints = args.source.vertexPoints;
            newObject.leaderHeight = args.source.leaderHeight;
          }

          if (this.prevSource.measureType === 'Radius') {
            newObject.notes = args.source.notes;
            this.commandHandler.annotation.updateCalibrateValues(this.prevSource);
          } // tslint:disable-next-line


          if (this.prevSource.shapeAnnotationType === 'FreeText' && this.commandHandler.selectedItems.annotations && this.commandHandler.selectedItems.annotations.length > 0) {
            this.commandHandler.nodePropertyChange(this.commandHandler.selectedItems.annotations[0], {});
          } // tslint:disable-next-line


          this.commandHandler.annotation.addAction(this.pageIndex, null, this.prevSource, 'Resize', '', this.redoElement, newObject);
        }

        this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, this.prevSource.id, 'Resize');
      }

      _super.prototype.mouseUp.call(this, args);

      return !this.blocked;
    };
    /**   @private  */


    ResizeTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      var object;
      object = args.source;
      this.currentPosition = args.position;
      var x = this.currentPosition.x - this.startPosition.x;
      var y = this.currentPosition.y - this.startPosition.y;
      x = x / this.commandHandler.viewerBase.getZoomFactor();
      y = y / this.commandHandler.viewerBase.getZoomFactor(); // tslint:disable-next-line

      var annotationElement = args.source; // tslint:disable-next-line

      var size = this.getPoints(x, y);
      var width = annotationElement.width + size.x;
      var height = annotationElement.height + size.y; // tslint:disable-next-line

      var obj = object;

      if (object && object.annotations) {
        // tslint:disable-next-line
        obj = object.annotations[0];
      } // tslint:disable-next-line


      var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(obj);
      var annotationMaxHeight = 0;
      var annotationMaxWidth = 0;
      var annotationMinHeight = 0;
      var annotationMinWidth = 0;

      if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {
        annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
        annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;
        annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;
        annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;
      }

      if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {
        // tslint:disable-next-line:max-line-length
        if (height >= annotationMinHeight && height <= annotationMaxHeight && width >= annotationMinWidth && width <= annotationMaxWidth) {
          x = x;
          y = y;
        } else {
          if (height < annotationMinHeight || height > annotationMaxHeight) {
            if (height < annotationMinHeight) {
              y = annotationMinHeight - annotationElement.height;
            } else {
              y = annotationMaxHeight - annotationElement.height;
            }
          }

          if (width < annotationMinWidth || width > annotationMaxWidth) {
            if (width < annotationMinWidth) {
              x = annotationMinWidth - annotationElement.width;
            } else {
              x = annotationMaxWidth - annotationElement.width;
            }
          }
        }
      }

      var changes = {
        x: x,
        y: y
      };
      changes = sf.drawings.rotatePoint(-this.currentElement.wrapper.rotateAngle, undefined, undefined, changes);
      var sx = (this.currentElement.wrapper.actualSize.width + changes.x) / this.currentElement.wrapper.actualSize.width;
      var sy = (this.currentElement.wrapper.actualSize.height + changes.y) / this.currentElement.wrapper.actualSize.height;
      changes = this.getChanges(changes);

      if (!this.helper) {
        // tslint:disable-next-line
        var cobject = cloneObject(this.commandHandler.selectedItems.annotations[0]);
        cobject.id = 'diagram_helper';

        if (cobject.shapeAnnotationType === 'Stamp') {
          cobject.strokeColor = '';
          cobject.borderDashArray = '';
          cobject.fillColor = 'transparent';
          cobject.stampFillColor = 'transparent';
          cobject.data = '';
        } else if (cobject.shapeAnnotationType === 'FreeText') {
          cobject.strokeColor = 'blue';
          cobject.fillColor = 'transparent';
          cobject.thickness = 1;
          cobject.opacity = 1;
          cobject.dynamicText = '';
        } else {
          cobject.bounds = this.commandHandler.selectedItems.annotations[0].wrapper.bounds;
          cobject.strokeColor = 'red';
          cobject.borderDashArray = '5,5';
          cobject.fillColor = 'transparent';
          cobject.thickness = 2;
          cobject.opacity = 1;
        }

        if (cobject.enableShapeLabel === true) {
          cobject.labelContent = '';
        }

        this.helper = cobject = this.commandHandler.add(cobject);
        this.commandHandler.selectedItems.annotations = [cobject];
      }

      var deltaValues = this.updateSize(this.helper, this.startPosition, this.currentPosition, this.corner, this.initialBounds);
      this.blocked = !this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.startPosition, this.currentPosition, this.helper);
      this.prevPosition = this.currentPosition;
      return !this.blocked;
    };
    /**   @private  */


    ResizeTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    };

    ResizeTool.prototype.getTooltipContent = function (pdfAnnotationBaseModel) {
      // tslint:disable-next-line:max-line-length
      return 'W:' + Math.round(pdfAnnotationBaseModel.wrapper.bounds.width) + ' ' + 'H:' + Math.round(pdfAnnotationBaseModel.wrapper.bounds.height);
    };

    ResizeTool.prototype.getChanges = function (change) {
      switch (this.corner) {
        case 'ResizeEast':
          return {
            x: change.x,
            y: 0
          };

        case 'ResizeSouthEast':
          return change;

        case 'ResizeSouth':
          return {
            x: 0,
            y: change.y
          };

        case 'ResizeNorth':
          return {
            x: 0,
            y: -change.y
          };

        case 'ResizeNorthEast':
          return {
            x: change.x,
            y: -change.y
          };

        case 'ResizeNorthWest':
          return {
            x: -change.x,
            y: -change.y
          };

        case 'ResizeWest':
          return {
            x: -change.x,
            y: 0
          };

        case 'ResizeSouthWest':
          return {
            x: -change.x,
            y: change.y
          };
      }

      return change;
    };

    ResizeTool.prototype.getPoints = function (x, y) {
      switch (this.corner) {
        case 'ResizeEast':
          return {
            x: x,
            y: 0
          };

        case 'ResizeSouthEast':
          return {
            x: x,
            y: y
          };

        case 'ResizeSouth':
          return {
            x: 0,
            y: y
          };

        case 'ResizeNorth':
          return {
            x: 0,
            y: -y
          };

        case 'ResizeNorthEast':
          return {
            x: x,
            y: -y
          };

        case 'ResizeNorthWest':
          return {
            x: -x,
            y: -y
          };

        case 'ResizeWest':
          return {
            x: -x,
            y: 0
          };

        case 'ResizeSouthWest':
          return {
            x: -x,
            y: y
          };
      }

      return {
        x: x,
        y: y
      };
    };
    /**
     * Updates the size with delta width and delta height using scaling.
     */

    /**
     * Aspect ratio used to resize the width or height based on resizing the height or width
     */


    ResizeTool.prototype.scaleObjects = function (deltaWidth, deltaHeight, corner, startPoint, endPoint, source) {
      if (source instanceof Selector && source.annotations.length === 1 && ( // tslint:disable-next-line:max-line-length
      source.annotations[0].shapeAnnotationType === 'Perimeter' || source.annotations[0].shapeAnnotationType === 'Radius' || source.shapeAnnotationType === 'Stamp')) {
        if (!(deltaHeight === 1 && deltaWidth === 1)) {
          deltaHeight = deltaWidth = Math.max(deltaHeight === 1 ? 0 : deltaHeight, deltaWidth === 1 ? 0 : deltaWidth);
        } else if (startPoint !== endPoint) {
          deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);
        } else {
          deltaHeight = deltaWidth = 0;
        } // tslint:disable-next-line:max-line-length

      } else if (source.shapeAnnotationType === 'Image' || source.shapeAnnotationType === 'HandWrittenSignature') {
        if (!(deltaHeight === 1 && deltaWidth === 1)) {
          deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);
        }
      } else {
        // tslint:disable-next-line:max-line-length
        if (source.shapeAnnotationType === 'Perimeter' || source.shapeAnnotationType === 'Radius' || source.shapeAnnotationType === 'Stamp') {
          // tslint:disable-next-line
          var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(source);
          var annotationMaxHeight = 0;
          var annotationMaxWidth = 0;

          if (annotationSettings.maxHeight || annotationSettings.maxWidth) {
            annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;
          }

          if (!annotationMaxHeight || !annotationMaxWidth) {
            if (!(deltaHeight === 1 && deltaWidth === 1)) {
              deltaHeight = deltaWidth = Math.max(deltaHeight === 1 ? 0 : deltaHeight, deltaWidth === 1 ? 0 : deltaWidth);
            }
          }
        }
      }

      var oldValue = {
        offsetX: source.wrapper.offsetX,
        offsetY: source.wrapper.offsetY
      };
      this.blocked = this.commandHandler.scaleSelectedItems(deltaWidth, deltaHeight, this.getPivot(this.corner));
      return this.blocked;
    };

    return ResizeTool;
  }(ToolBase);
  /**
   * Draws a node that is defined by the user
   * @hidden
   */


  var NodeDrawingTool =
  /** @class */
  function (_super) {
    __extends$2(NodeDrawingTool, _super);

    function NodeDrawingTool(commandHandler, base, sourceObject) {
      var _this = _super.call(this, commandHandler, base) || this;

      _this.sourceObject = sourceObject;
      return _this;
    }
    /**   @private  */


    NodeDrawingTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseDown.call(this, args);

      this.inAction = true;
      var node = {
        bounds: {
          x: 100,
          y: 300,
          width: 100,
          height: 100
        },
        pageIndex: 0,
        strokeColor: 'red',
        thickness: 3
      };
      node.id = sf.drawings.randomId();
      this.sourceObject.pageIndex = node.pageIndex = this.pdfViewerBase.activeElements.activePageID || 0;
      this.sourceObject.enableShapeLabel = this.commandHandler.enableShapeLabel;
      this.pdfViewerBase.updateFreeTextProperties(this.sourceObject); // tslint:disable-next-line

      this.commandHandler.drawingObject = this.drawingObject = this.commandHandler.add(this.sourceObject || node);
    };
    /**   @private  */


    NodeDrawingTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      if (this.inAction && sf.drawings.Point.equals(this.currentPosition, this.prevPosition) === false) {
        this.dragging = true;
        var rect = sf.drawings.Rect.toBounds([this.prevPosition, this.currentPosition]);
        this.updateNodeDimension(this.drawingObject, rect);

        if (this.drawingObject.shapeAnnotationType === 'Radius') {
          this.updateRadiusLinePosition(this.drawingObject.wrapper.children[1], this.drawingObject);
        }
      }

      return true;
    };
    /**   @private  */


    NodeDrawingTool.prototype.mouseUp = function (args) {
      if (this.drawingObject && this.dragging) {
        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
        this.commandHandler.select([this.drawingObject.id], this.commandHandler.annotationSelectorSettings);
        this.commandHandler.annotation.updateCalibrateValues(this.drawingObject);

        if (this.commandHandler) {
          // tslint:disable-next-line
          this.commandHandler.annotation.addAction(this.pageIndex, null, this.drawingObject, 'Addition', '', this.drawingObject, this.drawingObject);
        }

        this.drawingObject = null;
        this.dragging = false;

        _super.prototype.mouseUp.call(this, args);

        this.inAction = false;
      }
    };
    /**   @private  */


    NodeDrawingTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);
    };
    /**   @private  */


    NodeDrawingTool.prototype.updateNodeDimension = function (obj, rect) {
      var zoom = this.commandHandler.viewerBase.getZoomFactor();
      obj.bounds.x = rect.x / zoom + rect.width / zoom;
      obj.bounds.y = rect.y / zoom + rect.height / zoom;
      obj.bounds.width = rect.width / zoom;
      obj.bounds.height = rect.height / zoom; // tslint:disable-next-line

      var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(obj);
      var annotationMaxHeight = 0;
      var annotationMaxWidth = 0;

      if (annotationSettings.maxWidth || annotationSettings.maxHeight) {
        annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;
        annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;

        if (obj.bounds.width > annotationMaxWidth) {
          obj.bounds.width = annotationMaxWidth;
        }

        if (obj.bounds.height > annotationMaxHeight) {
          obj.bounds.height = annotationMaxHeight;
        } // tslint:disable-next-line:max-line-length


        if (obj.bounds.height <= annotationMaxHeight && obj.bounds.width <= annotationMaxWidth) {
          this.commandHandler.nodePropertyChange(obj, {
            bounds: obj.bounds
          });
        }
      } else {
        this.commandHandler.nodePropertyChange(obj, {
          bounds: obj.bounds
        });
      }
    };
    /**   @private  */


    NodeDrawingTool.prototype.updateRadiusLinePosition = function (obj, node) {
      var trasPoint = {
        x: node.bounds.x + node.bounds.width / 4,
        y: node.bounds.y
      };
      var center = {
        x: node.bounds.x + node.bounds.width / 2,
        y: node.bounds.y + node.bounds.height / 2
      };
      var matrix = sf.drawings.identityMatrix();
      sf.drawings.rotateMatrix(matrix, node.rotateAngle, center.x, center.y);
      var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, trasPoint);
      var newPoint1 = {
        x: rotatedPoint.x,
        y: rotatedPoint.y
      };
      obj.offsetX = newPoint1.x;
      obj.offsetY = newPoint1.y;
      obj.width = node.bounds.width / 2; // tslint:disable-next-line

      var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(node);
      var annotationMaxWidth = 0;

      if (annotationSettings.maxWidth) {
        annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;

        if (node.bounds.width > annotationMaxWidth) {
          node.bounds.width = annotationMaxWidth;
          obj.width = node.bounds.width / 2;
        }
      }

      this.commandHandler.renderDrawing(undefined, node.pageIndex);
    };

    return NodeDrawingTool;
  }(ToolBase);
  /**
   * Draws a Polygon shape node dynamically using polygon Tool
   * @hidden
   */


  var PolygonDrawingTool =
  /** @class */
  function (_super) {
    __extends$2(PolygonDrawingTool, _super);

    function PolygonDrawingTool(commandHandler, base, action) {
      var _this = _super.call(this, commandHandler, base) || this;

      _this.action = action;
      return _this;
    }
    /**   @private  */


    PolygonDrawingTool.prototype.mouseDown = function (args) {
      _super.prototype.mouseDown.call(this, args);

      this.inAction = true;

      if (!this.drawingObject) {
        this.startPoint = {
          x: this.startPosition.x,
          y: this.startPosition.y
        };
        var nodeAnnotElement = {
          bounds: {
            x: this.currentPosition.x,
            y: this.currentPosition.y,
            width: 5,
            height: 5 // tslint:disable-next-line:max-line-length

          },
          vertexPoints: [{
            x: this.startPoint.x / this.pdfViewerBase.getZoomFactor(),
            y: this.startPoint.y / this.pdfViewerBase.getZoomFactor()
          }, {
            x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),
            y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor()
          }],
          shapeAnnotationType: 'Line',
          fillColor: this.commandHandler.drawingObject.fillColor,
          strokeColor: this.commandHandler.drawingObject.strokeColor,
          pageIndex: this.pdfViewerBase.activeElements.activePageID,
          // tslint:disable-next-line:max-line-length
          notes: this.commandHandler.drawingObject.notes,
          thickness: this.commandHandler.drawingObject.thickness,
          author: this.commandHandler.drawingObject.author,
          subject: this.commandHandler.drawingObject.subject,
          borderDashArray: this.commandHandler.drawingObject.borderDashArray,
          modifiedDate: this.commandHandler.drawingObject.modifiedDate,
          borderStyle: this.commandHandler.drawingObject.borderStyle,
          // tslint:disable-next-line:max-line-length
          measureType: this.commandHandler.drawingObject.measureType,
          enableShapeLabel: this.commandHandler.enableShapeLabel,
          opacity: this.commandHandler.drawingObject.opacity
        };
        this.pdfViewerBase.updateFreeTextProperties(nodeAnnotElement); // tslint:disable-next-line

        this.drawingObject = this.commandHandler.add(nodeAnnotElement);
      } else {
        var pt = void 0;
        var obj = this.drawingObject;
        pt = obj.vertexPoints[obj.vertexPoints.length - 1];
        pt = {
          x: pt.x,
          y: pt.y
        };
        var lastPoint = this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1];

        if (!(lastPoint.x === pt.x && lastPoint.x === pt.y)) {
          this.drawingObject.vertexPoints.push(pt);
        }

        this.commandHandler.nodePropertyChange(obj, {
          vertexPoints: obj.vertexPoints
        });
      }
    };
    /**   @private  */


    PolygonDrawingTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      if (this.inAction && sf.drawings.Point.equals(this.currentPosition, this.prevPosition) === false) {
        this.dragging = true;
        var obj = this.drawingObject;

        if (this.drawingObject && this.currentPosition) {
          obj.vertexPoints[obj.vertexPoints.length - 1].x = this.currentPosition.x / this.pdfViewerBase.getZoomFactor();
          obj.vertexPoints[obj.vertexPoints.length - 1].y = this.currentPosition.y / this.pdfViewerBase.getZoomFactor();
          this.commandHandler.nodePropertyChange(obj, {
            vertexPoints: obj.vertexPoints
          });
        }

        if (obj.measureType === 'Perimeter') {
          updatePerimeterLabel(obj, obj.vertexPoints, this.commandHandler.annotation.measureAnnotationModule);
        }
      }

      return true;
    };
    /**   @private  */


    PolygonDrawingTool.prototype.mouseUp = function (args, isDoubleClineck, isMouseLeave) {
      _super.prototype.mouseMove.call(this, args); // tslint:disable-next-line


      var currentSelector;

      if (args.source && args.annotationSelectorSettings !== null) {
        currentSelector = args.source.annotationSelectorSettings;
      }

      if (this.drawingObject) {
        // tslint:disable-next-line:max-line-length
        var bounds = new sf.drawings.Rect(this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1].x - 20, this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1].y - 20, 40, 40);
        var point = {
          x: this.drawingObject.vertexPoints[0].x,
          y: this.drawingObject.vertexPoints[0].y
        };

        if ((bounds.containsPoint(point) || isDoubleClineck) && this.dragging) {
          if (this.inAction) {
            this.inAction = false;

            if (this.drawingObject) {
              if (!isMouseLeave) {
                if (this.drawingObject.vertexPoints.length > 2) {
                  this.drawingObject.vertexPoints.splice(this.drawingObject.vertexPoints.length - 1, 1);
                }
              }

              if (this.action === 'Polygon') {
                if (!isMouseLeave) {
                  // tslint:disable-next-line:max-line-length
                  this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1] = this.drawingObject.vertexPoints[0];
                } else {
                  // tslint:disable-next-line:max-line-length
                  this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length] = this.drawingObject.vertexPoints[0];
                }

                this.commandHandler.nodePropertyChange(this.drawingObject, {
                  vertexPoints: this.drawingObject.vertexPoints
                });
                var cobject = cloneObject(this.drawingObject);
                cobject.shapeAnnotationType = 'Polygon';
                cobject.bounds.width = cobject.wrapper.actualSize.width;
                cobject.bounds.height = cobject.wrapper.actualSize.height;
                cobject.bounds.x = this.drawingObject.wrapper.bounds.x;
                cobject.bounds.y = this.drawingObject.wrapper.bounds.y;
                this.commandHandler.add(cobject);
                this.commandHandler.remove(this.drawingObject);
                this.commandHandler.select([cobject.id], currentSelector);
                var drawingObject = this.commandHandler.selectedItems.annotations[0];

                if (drawingObject) {
                  // tslint:disable-next-line:max-line-length
                  if (this.commandHandler.enableShapeAnnotation && (sf.base.isNullOrUndefined(drawingObject.measureType) || drawingObject.measureType === '')) {
                    this.commandHandler.annotation.shapeAnnotationModule.renderShapeAnnotations(drawingObject, drawingObject.pageIndex);
                  } // tslint:disable-next-line:max-line-length


                  if (this.commandHandler.enableMeasureAnnotation && (drawingObject.measureType === 'Area' || drawingObject.measureType === 'Volume')) {
                    if (drawingObject.measureType === 'Area') {
                      // tslint:disable-next-line:max-line-length
                      drawingObject.notes = this.commandHandler.annotation.measureAnnotationModule.calculateArea(drawingObject.vertexPoints);
                      this.commandHandler.annotation.stickyNotesAnnotationModule.addTextToComments(drawingObject.annotName, drawingObject.notes);
                    } else if (drawingObject.measureType === 'Volume') {
                      // tslint:disable-next-line:max-line-length
                      drawingObject.notes = this.commandHandler.annotation.measureAnnotationModule.calculateVolume(drawingObject.vertexPoints);
                      this.commandHandler.annotation.stickyNotesAnnotationModule.addTextToComments(drawingObject.annotName, drawingObject.notes);
                    }

                    if (drawingObject.enableShapeLabel) {
                      drawingObject.labelContent = drawingObject.notes; // tslint:disable-next-line:max-line-length

                      this.commandHandler.nodePropertyChange(drawingObject, {
                        vertexPoints: drawingObject.vertexPoints,
                        notes: drawingObject.notes
                      });
                    } // tslint:disable-next-line:max-line-length


                    this.commandHandler.annotation.measureAnnotationModule.renderMeasureShapeAnnotations(drawingObject, drawingObject.pageIndex);
                  }
                }
              } else {
                if (!isMouseLeave) {
                  if (isDoubleClineck) {
                    this.drawingObject.vertexPoints.splice(this.drawingObject.vertexPoints.length - 1, 1);
                  }
                }

                this.commandHandler.nodePropertyChange(this.drawingObject, {
                  // tslint:disable-next-line:max-line-length
                  vertexPoints: this.drawingObject.vertexPoints,
                  sourceDecoraterShapes: this.commandHandler.drawingObject.sourceDecoraterShapes,
                  taregetDecoraterShapes: this.commandHandler.drawingObject.taregetDecoraterShapes
                });
                this.commandHandler.select([this.drawingObject.id], currentSelector);

                if (this.commandHandler.enableMeasureAnnotation && this.drawingObject.measureType === 'Perimeter') {
                  this.commandHandler.renderDrawing(null, this.drawingObject.pageIndex); // tslint:disable-next-line:max-line-length

                  this.drawingObject.notes = this.commandHandler.annotation.measureAnnotationModule.calculatePerimeter(this.drawingObject);

                  if (this.drawingObject.enableShapeLabel) {
                    this.drawingObject.labelContent = this.drawingObject.notes; // tslint:disable-next-line:max-line-length

                    this.commandHandler.nodePropertyChange(this.drawingObject, {
                      vertexPoints: this.drawingObject.vertexPoints,
                      notes: this.drawingObject.notes
                    });
                  } // tslint:disable-next-line:max-line-length


                  this.commandHandler.annotation.stickyNotesAnnotationModule.addTextToComments(this.drawingObject.annotName, this.drawingObject.notes); // tslint:disable-next-line:max-line-length

                  this.commandHandler.annotation.measureAnnotationModule.renderMeasureShapeAnnotations(this.drawingObject, this.drawingObject.pageIndex);
                }
              }

              var annotationObject = this.commandHandler.selectedItems.annotations[0]; // tslint:disable-next-line

              this.commandHandler.annotation.addAction(this.pageIndex, null, annotationObject, 'Addition', '', annotationObject, annotationObject);
              this.drawingObject = null;
            }
          }

          this.endAction();
        } else if (this.inAction && !this.dragging) {
          this.commandHandler.remove(this.drawingObject);
        }
      }
    };
    /**   @private  */


    PolygonDrawingTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args, true, true);
    };
    /**   @private  */


    PolygonDrawingTool.prototype.mouseWheel = function (args) {
      _super.prototype.mouseWheel.call(this, args);

      this.mouseMove(args);
    };
    /**   @private  */


    PolygonDrawingTool.prototype.endAction = function () {
      this.inAction = false;
      this.drawingObject = null;
      this.commandHandler.tool = '';
    };

    return PolygonDrawingTool;
  }(ToolBase);
  /**
   * Helps to edit the selected connectors
   * @hidden
   */


  var LineTool =
  /** @class */
  function (_super) {
    __extends$2(LineTool, _super);

    function LineTool(commandHandler, base, endPoint, drawingObject) {
      var _this = _super.call(this, commandHandler, base, true) || this;

      _this.endPoint = endPoint;
      _this.drawingObject = drawingObject;
      return _this;
    }
    /**   @private  */


    LineTool.prototype.mouseDown = function (args) {
      this.inAction = true;
      this.undoElement = undefined;

      _super.prototype.mouseDown.call(this, args);

      var oldPointValue;
      var connectorsShape;

      if (args.source && args.source.annotations) {
        oldPointValue = {
          x: this.prevPosition.x,
          y: this.prevPosition.y
        };
        connectorsShape = this.drawingObject;
      }

      this.initialPosition = args.position;
      this.prevSource = this.drawingObject;
      this.currentPosition = args.position;

      if (!this.drawingObject) {
        var measureModule = this.commandHandler.annotation.measureAnnotationModule;
        var annotationNode = {
          // tslint:disable-next-line:max-line-length
          vertexPoints: [{
            x: this.startPosition.x / this.pdfViewerBase.getZoomFactor(),
            y: this.startPosition.y / this.pdfViewerBase.getZoomFactor()
          }, {
            x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),
            y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor()
          }],
          bounds: {
            x: this.currentPosition.x,
            y: this.currentPosition.y,
            width: 5,
            height: 5
          },
          sourceDecoraterShapes: this.commandHandler.drawingObject.sourceDecoraterShapes,
          taregetDecoraterShapes: this.commandHandler.drawingObject.taregetDecoraterShapes,
          measureType: 'Distance',
          // tslint:disable-next-line:max-line-length
          fillColor: this.commandHandler.drawingObject.fillColor,
          notes: this.commandHandler.drawingObject.notes,
          strokeColor: this.commandHandler.drawingObject.strokeColor,
          opacity: this.commandHandler.drawingObject.opacity,
          thickness: this.commandHandler.drawingObject.thickness,
          borderDashArray: this.commandHandler.drawingObject.borderDashArray,
          // tslint:disable-next-line:max-line-length
          shapeAnnotationType: 'Distance',
          pageIndex: this.pdfViewerBase.activeElements.activePageID,
          author: this.commandHandler.drawingObject.author,
          subject: this.commandHandler.drawingObject.subject,
          enableShapeLabel: this.commandHandler.enableShapeLabel,
          leaderHeight: measureModule.leaderLength
        };
        this.pdfViewerBase.updateFreeTextProperties(annotationNode); // tslint:disable-next-line

        this.drawingObject = this.commandHandler.add(annotationNode);
      } else if (!this.dragging) {
        var nodeAnnot = {
          bounds: {
            x: this.currentPosition.x,
            y: this.currentPosition.y,
            width: 5,
            height: 5 // tslint:disable-next-line:max-line-length

          },
          vertexPoints: [{
            x: this.startPosition.x / this.pdfViewerBase.getZoomFactor(),
            y: this.startPosition.y / this.pdfViewerBase.getZoomFactor()
          }, {
            x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),
            y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor()
          }],
          // tslint:disable-next-line:max-line-length
          shapeAnnotationType: this.drawingObject.shapeAnnotationType,
          sourceDecoraterShapes: this.drawingObject.sourceDecoraterShapes,
          taregetDecoraterShapes: this.drawingObject.taregetDecoraterShapes,
          fillColor: this.drawingObject.fillColor,
          strokeColor: this.drawingObject.strokeColor,
          pageIndex: this.pdfViewerBase.activeElements.activePageID,
          // tslint:disable-next-line:max-line-length
          opacity: this.drawingObject.opacity || 1,
          borderDashArray: this.drawingObject.borderDashArray,
          thickness: this.drawingObject.thickness,
          modifiedDate: this.drawingObject.modifiedDate,
          author: this.drawingObject.author,
          subject: this.drawingObject.subject,
          lineHeadEnd: this.drawingObject.lineHeadEnd,
          lineHeadStart: this.drawingObject.lineHeadStart,
          measureType: this.commandHandler.drawingObject.measureType,
          enableShapeLabel: this.commandHandler.enableShapeLabel
        };
        this.pdfViewerBase.updateFreeTextProperties(nodeAnnot); // tslint:disable-next-line

        this.drawingObject = this.commandHandler.add(nodeAnnot);
      }
    };
    /**   @private  */


    LineTool.prototype.mouseUp = function (args) {
      if (this.dragging) {
        _super.prototype.mouseMove.call(this, args);

        if (this.commandHandler) {
          // tslint:disable-next-line
          var currentSelector = void 0;

          if (args.source && args.annotationSelectorSettings !== null) {
            currentSelector = args.source.annotationSelectorSettings;
          } else {
            currentSelector = '';
          }

          var node = this.drawingObject;
          this.commandHandler.nodePropertyChange(node, {
            vertexPoints: node.vertexPoints,
            leaderHeight: node.leaderHeight
          });
          this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);
          this.commandHandler.select([node.id], currentSelector);
          this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);
        }

        if (this.endPoint && this.endPoint.indexOf('ConnectorSegmentPoint') > -1 && this.dragging) {
          this.commandHandler.annotation.updateCalibrateValues(this.drawingObject); // tslint:disable-next-line

          this.commandHandler.annotation.addAction(this.pageIndex, null, this.drawingObject, 'Addition', '', this.drawingObject, this.drawingObject);
          this.drawingObject = null;
          this.dragging = false;

          _super.prototype.mouseUp.call(this, args);
        }

        if (this.drawingObject) {
          this.endPoint = 'ConnectorSegmentPoint_1';
        }
      } else {
        if (this.drawingObject) {
          this.commandHandler.remove(this.drawingObject);
        }
      }
    };
    /**   @private  */


    LineTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      if (this.inAction && sf.drawings.Point.equals(this.currentPosition, this.prevPosition) === false) {
        var connector = void 0;
        this.currentPosition = args.position;
        this.dragging = true;

        if (this.currentPosition && this.prevPosition) {
          var diffX = this.currentPosition.x - this.prevPosition.x;
          var diffY = this.currentPosition.y - this.prevPosition.y;
          connector = this.drawingObject;
          var currentSelector = void 0;

          if (args.source && args.annotationSelectorSettings !== null) {
            currentSelector = args.source.annotationSelectorSettings;
          } else {
            currentSelector = '';
          } // tslint:disable-next-line:max-line-length


          if (this.inAction && this.commandHandler && this.drawingObject && this.endPoint !== undefined && diffX !== 0 || diffY !== 0) {
            // tslint:disable-next-line:max-line-length
            this.blocked = !this.commandHandler.dragConnectorEnds(this.endPoint, this.drawingObject, this.currentPosition, this.selectedSegment, args.target, null, currentSelector);
            this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);
          }
        }

        this.prevPosition = this.currentPosition;
      }

      return !this.blocked;
    };
    /**   @private  */


    LineTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    };
    /**   @private  */


    LineTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);

      this.prevPosition = null;
      this.endPoint = null;
    };

    return LineTool;
  }(ToolBase);
  /**
   * Rotates the selected objects
   * @hidden
   */


  var RotateTool =
  /** @class */
  function (_super) {
    __extends$2(RotateTool, _super);

    function RotateTool(commandHandler, base) {
      return _super.call(this, commandHandler, base, true) || this;
    }
    /**   @private  */


    RotateTool.prototype.mouseDown = function (args) {
      var nodeMouseDown = cloneObject(args.source);
      this.undoElement = {
        bounds: {
          x: nodeMouseDown.wrapper.offsetX,
          y: nodeMouseDown.wrapper.offsetY,
          width: nodeMouseDown.wrapper.actualSize.width,
          height: nodeMouseDown.wrapper.actualSize.height
        },
        rotateAngle: nodeMouseDown.rotateAngle // tslint:disable-next-line

      };

      _super.prototype.mouseDown.call(this, args);
    };
    /**   @private  */


    RotateTool.prototype.mouseUp = function (args) {
      var object;
      object = args.source; // tslint:disable-next-line

      var newShapeObject;

      if (this.undoElement.rotateAngle !== object.wrapper.rotateAngle) {
        var oldValue = {
          rotateAngle: object.wrapper.rotateAngle
        };
        var obj = void 0;
        obj = cloneObject(args.source); // tslint:disable-next-line

        var currentSelector = args.source.annotations[0].annotationSelectorSettings;
        this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);
        newShapeObject = {
          bounds: {
            x: args.source.wrapper.offsetX,
            y: args.source.wrapper.offsetY,
            width: args.source.wrapper.actualSize.width,
            height: args.source.wrapper.actualSize.height
          },
          rotateAngle: args.source.wrapper.rotateAngle
        };
      } // tslint:disable-next-line


      this.commandHandler.annotation.addAction(this.pageIndex, null, args.source, 'Rotate', '', this.undoElement, newShapeObject);
      this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, null, 'Rotate');
      this.commandHandler.annotation.stickyNotesAnnotationModule.updateStickyNotes(args.source, null);

      _super.prototype.mouseUp.call(this, args);
    };
    /**   @private  */


    RotateTool.prototype.mouseMove = function (args) {
      _super.prototype.mouseMove.call(this, args);

      var object;
      object = args.source; // tslint:disable-next-line

      var currentSelector = args.source.annotations[0].annotationSelectorSettings;
      this.currentPosition = args.position;

      if (object.wrapper) {
        var refPoint = {
          x: object.wrapper.offsetX,
          y: object.wrapper.offsetY
        };
        var angle = sf.drawings.Point.findAngle(refPoint, this.currentPosition) + 90;
        angle = (angle + 360) % 360;
        var oldValue = {
          rotateAngle: object.wrapper.rotateAngle
        };
        this.blocked = !this.commandHandler.rotate(angle - object.wrapper.rotateAngle, currentSelector);
      }

      return !this.blocked;
    };

    RotateTool.prototype.getTooltipContent = function (node) {
      return Math.round(node.rotateAngle % 360).toString() + '\xB0';
    };
    /**   @private  */


    RotateTool.prototype.mouseLeave = function (args) {
      this.mouseUp(args);
    };
    /**   @private  */


    RotateTool.prototype.endAction = function () {
      _super.prototype.endAction.call(this);
    };

    return RotateTool;
  }(ToolBase);
  /** @private */
  // tslint:disable-next-line


  function findActiveElement(event, pdfBase, pdfViewer, isOverlapped) {
    if (pdfViewer && pdfBase.activeElements.activePageID > -1) {
      var objects = findObjectsUnderMouse(pdfBase, pdfViewer, event);
      var object = findObjectUnderMouse(objects, event, pdfBase, pdfViewer);

      if (isOverlapped) {
        return objects;
      }

      return object;
    }

    return undefined;
  }
  /** @private */


  function findObjectsUnderMouse(pdfBase, pdfViewer, event) {
    var pt = pdfBase.currentPosition || {
      x: event.offsetX,
      y: event.offsetY
    };
    pt = {
      x: pt.x / pdfBase.getZoomFactor(),
      y: pt.y / pdfBase.getZoomFactor()
    };
    var pageTable = pdfViewer.getPageTable(pdfBase.activeElements.activePageID);
    var objArray = findObjects(pt, pageTable.objects);
    return objArray;
  }
  /** @private */


  function findObjectUnderMouse( // tslint:disable-next-line
  objects, event, pdfBase, pdfViewer) {
    var actualTarget = null;
    var touchArg;
    var offsetX;
    var offsetY;

    if (event && event.type && event.type.indexOf('touch') !== -1) {
      touchArg = event;

      if (pdfViewer.annotation) {
        var pageDiv = pdfBase.getElement('_pageDiv_' + pdfViewer.annotation.getEventPageNumber(event));

        if (pageDiv) {
          var pageCurrentRect = pageDiv.getBoundingClientRect();
          offsetX = touchArg.changedTouches[0].clientX - pageCurrentRect.left;
          offsetY = touchArg.changedTouches[0].clientY - pageCurrentRect.top;
        }
      }
    } else {
      offsetX = !isNaN(event.offsetX) ? event.offsetX : event.position ? event.position.x : 0;
      offsetY = !isNaN(event.offsetY) ? event.offsetY : event.position ? event.position.y : 0;
    }

    var offsetForSelector = 5;
    var boundsDiff = 0;

    for (var i = 0; i < objects.length; i++) {
      // tslint:disable-next-line:max-line-length
      if (!(objects[i].shapeAnnotationType === 'Distance' || objects[i].shapeAnnotationType === 'Line' || objects[i].shapeAnnotationType === 'LineWidthArrowHead' || pdfBase.tool instanceof LineTool)) {
        var bounds = objects[i].wrapper.bounds;
        var rotationValue = 0;

        if (objects[i].shapeAnnotationType === 'Stamp') {
          rotationValue = 25;
        } // tslint:disable-next-line:max-line-length


        if ((bounds.x - offsetForSelector) * pdfBase.getZoomFactor() < offsetX && (bounds.x + bounds.width + offsetForSelector) * pdfBase.getZoomFactor() > offsetX && (bounds.y - offsetForSelector - rotationValue) * pdfBase.getZoomFactor() < offsetY && (bounds.y + bounds.height + offsetForSelector) * pdfBase.getZoomFactor() > offsetY) {
          if (pdfBase.tool instanceof NodeDrawingTool) {
            actualTarget = objects[i];
          } else {
            if (!boundsDiff) {
              actualTarget = objects[i]; // tslint:disable-next-line:max-line-length

              boundsDiff = offsetX - (bounds.x - offsetForSelector) * pdfBase.getZoomFactor() + ((bounds.x + bounds.width + offsetForSelector) * pdfBase.getZoomFactor() - offsetX) + (offsetY - (bounds.y - offsetForSelector - rotationValue) * pdfBase.getZoomFactor()) + ((bounds.y + bounds.height + offsetForSelector) * pdfBase.getZoomFactor() - offsetY);
            } else {
              // tslint:disable-next-line:max-line-length
              var objectBounds = offsetX - (bounds.x - offsetForSelector) * pdfBase.getZoomFactor() + ((bounds.x + bounds.width + offsetForSelector) * pdfBase.getZoomFactor() - offsetX) + (offsetY - (bounds.y - offsetForSelector - rotationValue) * pdfBase.getZoomFactor()) + ((bounds.y + bounds.height + offsetForSelector) * pdfBase.getZoomFactor() - offsetY);

              if (boundsDiff > objectBounds) {
                actualTarget = objects[i];
                boundsDiff = objectBounds;
              }
            }
          }
        }
      } else {
        var pt = {
          x: offsetX / pdfBase.getZoomFactor(),
          y: offsetY / pdfBase.getZoomFactor()
        };
        var obj = findElementUnderMouse(objects[i], pt, offsetForSelector);
        var isOver = isPointOverConnector(objects[i], pt);

        if (obj && !isOver) {
          var newpoint = CalculateLeaderPoints(objects[i], obj);

          if (newpoint) {
            var rect = sf.drawings.Rect.toBounds([newpoint, newpoint]);
            rect.Inflate(10);

            if (rect.containsPoint(pt)) {
              isOver = true;
            }
          }
        }

        if (obj && isOver) {
          actualTarget = objects[i];
        }
      }
    }

    return actualTarget;
  }
  /** @private */
  // tslint:disable-next-line


  function CalculateLeaderPoints(selector, currentobject) {
    var leaderCount = 0;
    var sourcePoint = selector.sourcePoint;
    var targetPoint = selector.targetPoint;

    if (selector.shapeAnnotationType === 'Distance') {
      var segment = currentobject;
      var newPoint1 = void 0;
      var angle = sf.drawings.Point.findAngle(selector.sourcePoint, selector.targetPoint);

      if (segment.id.indexOf('leader') > -1) {
        var center = selector.wrapper.children[0].bounds.center;

        if (leaderCount === 0 && segment.id.indexOf('leader1') > -1) {
          newPoint1 = {
            x: selector.sourcePoint.x,
            y: selector.sourcePoint.y - selector.leaderHeight
          };
          center = sourcePoint;
        } else {
          newPoint1 = {
            x: selector.targetPoint.x,
            y: selector.targetPoint.y - selector.leaderHeight
          };
          center = targetPoint;
        }

        var matrix = sf.drawings.identityMatrix();
        sf.drawings.rotateMatrix(matrix, angle, center.x, center.y);
        var rotatedPoint = sf.drawings.transformPointByMatrix(matrix, {
          x: newPoint1.x,
          y: newPoint1.y
        });
        return rotatedPoint;
      }
    }
  }
  /** @private */


  function findElementUnderMouse(obj, position, padding) {
    return findTargetShapeElement(obj.wrapper, position, padding);
  }
  /** @private */


  function insertObject(obj, key, collection) {
    if (collection.length === 0) {
      collection.push(obj);
    } else if (collection.length === 1) {
      // tslint:disable-next-line
      if (collection[0][key] > obj[key]) {
        collection.splice(0, 0, obj);
      } else {
        collection.push(obj);
      }
    } else if (collection.length > 1) {
      var low = 0;
      var high = collection.length - 1;
      var mid = Math.floor((low + high) / 2);

      while (mid !== low) {
        // tslint:disable-next-line
        if (collection[mid][key] < obj[key]) {
          low = mid;
          mid = Math.floor((low + high) / 2); // tslint:disable-next-line
        } else if (collection[mid][key] > obj[key]) {
          high = mid;
          mid = Math.floor((low + high) / 2);
        }
      } // tslint:disable-next-line


      if (collection[high][key] < obj[key]) {
        collection.push(obj); // tslint:disable-next-line
      } else if (collection[low][key] > obj[key]) {
        collection.splice(low, 0, obj); // tslint:disable-next-line
      } else if (collection[low][key] < obj[key] && collection[high][key] > obj[key]) {
        collection.splice(high, 0, obj);
      }
    }
  }
  /** @private */


  function findTargetShapeElement(container, position, padding) {
    if (container && container.children) {
      for (var i = container.children.length - 1; i >= 0; i--) {
        var shapeElement = container.children[i];

        if (shapeElement && shapeElement.bounds.containsPoint(position, 10)) {
          if (shapeElement instanceof sf.drawings.Container) {
            var targetElement = this.findTargetElement(shapeElement, position);

            if (targetElement) {
              return targetElement;
            }
          }

          if (shapeElement.bounds.containsPoint(position, 10)) {
            return shapeElement;
          }
        }
      }
    }

    if (container && container.bounds.containsPoint(position, padding) && container.style.fill !== 'none') {
      return container;
    }

    return null;
  }
  /** @private */


  function findObjects(region, objCollection) {
    var objects = [];

    for (var _i = 0, objCollection_1 = objCollection; _i < objCollection_1.length; _i++) {
      var obj = objCollection_1[_i];

      if (findElementUnderMouse(obj, region, 10) || obj.shapeAnnotationType === 'Stamp' && findElementUnderMouse(obj, region, 40)) {
        insertObject(obj, 'zIndex', objects);
      }
    }

    return objects;
  }
  /** @private */


  function findActivePage(event, pdfBase) {
    var activePageID = undefined;

    if (event.target && event.target.wrapper) {
      return event.target.pageIndex;
    }

    if (event.target) {
      var elementIdColl = event.target.id.split('_');

      if (elementIdColl.length > 0) {
        // tslint:disable-next-line:radix
        activePageID = parseInt(elementIdColl[elementIdColl.length - 1]);
      }
    }

    return activePageID;
  }
  /**
   * @hidden
   */


  var ActiveElements =
  /** @class */
  function () {
    function ActiveElements() {
      this.activePage = undefined;
      this.activePageID = undefined;
    }

    Object.defineProperty(ActiveElements.prototype, "activePageID", {
      /** @private */
      get: function get() {
        return this.activePage;
      },

      /** @private */
      set: function set(offset) {
        this.activePage = offset; // tslint:disable-next-line

        if (offset !== this.activePage) {}
      },
      enumerable: true,
      configurable: true
    });
    return ActiveElements;
  }();
  /**
   * @hidden
   */


  function renderAdornerLayer(bounds, commonStyle, cavas, index, pdfViewer) {
    var divElement = sf.drawings.createHtmlElement('div', {
      'id': pdfViewer.element.id + index + '_diagramAdornerLayer',
      'style': 'width:' + bounds.width + 'px;height:' + bounds.height + 'px;' + commonStyle
    });

    if (!sf.drawings.getDiagramElement(divElement.id)) {
      var svgAdornerSvg = createSvg(pdfViewer.element.id + index + '_diagramAdorner_svg', bounds.width, bounds.height);
      svgAdornerSvg.setAttribute('class', 'e-adorner-layer' + index);
      svgAdornerSvg.setAttribute('style', 'pointer-events:none;');
      pdfViewer.adornerSvgLayer = sf.drawings.createSvgElement('g', {
        'id': pdfViewer.element.id + '_diagramAdorner'
      });
      pdfViewer.adornerSvgLayer.setAttribute('style', ' pointer-events: all; ');
      svgAdornerSvg.appendChild(pdfViewer.adornerSvgLayer);
      divElement.appendChild(svgAdornerSvg);
      cavas.parentElement.appendChild(divElement);
      var svgSelector = sf.drawings.createSvgElement('g', {
        'id': pdfViewer.element.id + '_SelectorElement'
      });
      pdfViewer.adornerSvgLayer.appendChild(svgSelector);
      sf.drawings.setAttributeSvg(svgAdornerSvg, {
        style: 'pointer-events:none;'
      });
    }

    pdfViewer.viewerBase.applyElementStyles(divElement, index);
  }
  /**
   * @hidden
   */


  function createSvg(id, width, height) {
    var svgObj = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    sf.drawings.setAttributeSvg(svgObj, {
      'id': id,
      'width': width,
      'height': height
    });
    return svgObj;
  }

  exports.Drawing = Drawing;
  exports.findActiveElement = findActiveElement;
  exports.findObjectsUnderMouse = findObjectsUnderMouse;
  exports.findObjectUnderMouse = findObjectUnderMouse;
  exports.CalculateLeaderPoints = CalculateLeaderPoints;
  exports.findElementUnderMouse = findElementUnderMouse;
  exports.insertObject = insertObject;
  exports.findTargetShapeElement = findTargetShapeElement;
  exports.findObjects = findObjects;
  exports.findActivePage = findActivePage;
  exports.ActiveElements = ActiveElements;
  exports.renderAdornerLayer = renderAdornerLayer;
  exports.createSvg = createSvg;
  exports.ToolBase = ToolBase;
  exports.SelectTool = SelectTool;
  exports.MoveTool = MoveTool;
  exports.StampTool = StampTool;
  exports.InkDrawingTool = InkDrawingTool;
  exports.ConnectTool = ConnectTool;
  exports.ResizeTool = ResizeTool;
  exports.NodeDrawingTool = NodeDrawingTool;
  exports.PolygonDrawingTool = PolygonDrawingTool;
  exports.LineTool = LineTool;
  exports.RotateTool = RotateTool;
  exports.PdfBounds = PdfBounds;
  exports.PdfFont = PdfFont;
  exports.PdfAnnotationBase = PdfAnnotationBase;
  exports.ZOrderPageTable = ZOrderPageTable;
  exports.Selector = Selector;
  exports.isLineShapes = isLineShapes;
  exports.setElementStype = setElementStype;
  exports.findPointsLength = findPointsLength;
  exports.findPerimeterLength = findPerimeterLength;
  exports.getBaseShapeAttributes = getBaseShapeAttributes;
  exports.getFunction = getFunction;
  exports.cloneObject = cloneObject;
  exports.cloneArray = cloneArray;
  exports.getInternalProperties = getInternalProperties;
  exports.isLeader = isLeader;
  exports.getConnectorPoints = getConnectorPoints;
  exports.getSegmentPath = getSegmentPath;
  exports.updateSegmentElement = updateSegmentElement;
  exports.getSegmentElement = getSegmentElement;
  exports.updateDecoratorElement = updateDecoratorElement;
  exports.getDecoratorElement = getDecoratorElement;
  exports.clipDecorators = clipDecorators;
  exports.clipDecorator = clipDecorator;
  exports.initDistanceLabel = initDistanceLabel;
  exports.updateDistanceLabel = updateDistanceLabel;
  exports.updateRadiusLabel = updateRadiusLabel;
  exports.initPerimeterLabel = initPerimeterLabel;
  exports.updatePerimeterLabel = updatePerimeterLabel;
  exports.removePerimeterLabel = removePerimeterLabel;
  exports.updateCalibrateLabel = updateCalibrateLabel;
  exports.getPolygonPath = getPolygonPath;
  exports.textElement = textElement;
  exports.initLeaders = initLeaders;
  exports.initLeader = initLeader;
  exports.isPointOverConnector = isPointOverConnector;
  exports.findNearestPoint = findNearestPoint;
  exports.getDecoratorShape = getDecoratorShape;
  return exports;
};

sfBlazor.modules["pdfviewerbase"] = "pdfviewer.Drawing";
window.sf.pdfviewer = window.sf.base.extend({}, window.sf.pdfviewer, pdfviewerbase({}));

/***/ })

}]);